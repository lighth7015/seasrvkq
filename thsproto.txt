                (документ недописан, в стадии разработки)

                            Проект TheSender
                                                                        
                         Спецификация протокола

                               Версия 0.1

                   Автор: Vadim S. Goncharov (TPU AVTF)

                       Томск, Июль - Октябрь 2006


                               СОДЕРЖАНИЕ

   1. Введение.

      1.1. Требуемая функциональность.
      1.2. Мотивация.
      1.3. Назначение.
      1.4. Об этом документе.

   2. Философия (общие принципы).

      2.1. Типографские соглашения.
      2.2. Среда действия и базовые понятия.
      2.3. Соединение между двумя узлами.
      2.4. Взаимодействие клиента и сервера.
      2.5. Группы.
      2.6. Сообщения.
      2.7. Дополнительные возможности: дейтаграммы.
      2.8. Работа сети в целом.

   3. Спецификация формата.

      3.1. Базовые элементы.
      3.2. Формат фрейма и его заголовка.
      3.3. Структура информации об узле.
      3.4. Заголовок сообщения.
      3.5. Дейтаграммы.
      3.6. Атрибуты.
      3.7. Дополнительные структуры узла.

   4. Справочник по командам.

      4.1. Общие статусные коды.
      4.2. Манипуляции соединениями.
      4.3. Узлы и группы.
      4.4. Сообщения.
      4.5. Прочие команды.

   5. Ссылки.

   Приложения:

   A. Форматирование текста.

   B. Чат и передача файлов.

   C. Языки и кодовые страницы.


1. ВВЕДЕНИЕ.

   Проект TheSender посвящен написанию пакета программ (модель -
   клиент-серверная) обмена мгновенными сообщениями в средних и
   больших локальных сетях, в том числе совокупности таких сетей,
   разделенных маршрутизаторами. Особенность проекта - ориентация
   на групповые сообщения.

   Данный документ описывает функции протокола общения программ пакета
   TheSender и стандартизирует требования к таким программам по их
   взаимодействию между собой.

1.1. Требуемая функциональность.

   Основное назначение протокола - обмен мгновенными сообщениями между
   пользователями. Это включает в себя:

   *  возможность посылки достаточно большого текстового сообщения
      выбранному пользователю или их группе;

   *  возможность свободного формирования групп пользователей в
      реальном времени с возможностью вхождения пользователя
      одновременно в несколько разных групп, с целью обеспечения
      возможности доставки сообщений (либо других операций)
      разным группам пользователей;

   *  возможность доставки сообщения позднее пользователю, который
      в данный момент недоступен (в том числе запрос пользователем
      с сервера групповых сообщений, отправленных в его отсутствие);

   *  возможность разделения приоритетов сообщений отправителем и
      фильтрацию нежелательных сообщений получателем (в том числе
      обеспечение невозможности фильтрации сообщений особой важности,
      например, административных оповещений), а также возможность
      ограничения "сетевого хулиганства";

   *  возможность гибкой индикации статуса доступности пользователя
      для сообщений (и прочих возможностей);

   *  возможность обеспечения диалога в реальном времени (чата) между
      любыми двумя пользователями в сети в случае необходимости;

   *  возможность пересылки файлов между двумя любыми пользователями
      в сети.

   Кроме того, протокол должен обеспечивать следующие дополнительные
   возможности:

   *  возможность автоматической настройки клиента на сервер,
      находящийся с ним в одной подсети;

   *  возможность полноценной работы клиента при условии частичной или
      полной потери возможности его связи с другими клиентами, но не
      с сервером - в это входит, например, работа клиентом за
      файрволом, полностью блокирующим входящие (и исходящие, кроме
      одного порта на сервере) соединения;

   *  возможность сохранения большей части функциональности клиентов и
      их взаимодействия между собой в бессерверном режиме в одной
      подсети - например, в случае отказа сервера;

   *  возможность значительного (если не любого возможного) расширения
      функций протокола и использование их между теми программами,
      которые поддерживают их, при неизменности базового протокола и,
      таким образом, сохранении их совместимости с теми программами,
      которые данные расширения не поддерживают.

   Помимо этого, к протоколу предъявляется обязательное требование
   открытости, с тем, чтобы была возможна его стандартизация и
   широкое распространение использующих его (возможно, конкурирующих)
   программных продуктов. Опыт показывает, что использование закрытых
   протоколов ведет к появлению конкурирующих несовместимых программ,
   вынужденных делить между собой базу пользователей.

   Немаловажным требованием является также достаточная простота
   реализации и минимизация использования ресурсов (в том числе
   трафика) как на машинах конечных пользователей (поскольку это могут
   быть, к примеру, мобильные устройства), так и на серверах, поскольку
   им необходимо обслуживать как можно большее количество пользователей
   с минимальной задержкой даже на относительно недорогом оборудовании
   (каковое имеет место быть, к примеру, в домашних сетях).

1.2. Мотивация.

   В локальных сетях, связывающих компьютеры, располагающиеся более чем
   в одной комнате, появляется необходимость в средстве общения между
   пользователями "не отходя от компьютера". В случае малых локальных
   сетей эта проблема может быть решена с использованием стандартных
   программ, входящих в состав операционных систем, таких, как WinPopUp
   (net send) под Windows, ntalk под Unix.

   В случае сетей большего размера, однако, возникает необходимость в
   более функциональных программах: в частности, может потребоваться
   послать сообщение всем или выбранной группе пользователей, отправить
   файл, сделать административное оповещение особой срочности и т.п.

   Существующие программы такого назначения нередко либо (1) не
   обеспечивают в точности требуемой функциональности, либо (2)
   становятся малопригодны по мере увеличения размеров сети.

   В качестве примеров по первому пункту можно привести использование в
   подобном качестве технологий e-mail, IRC, ICQ и NNTP.

   Недостатки e-mail в данном плане очевидны - требуется быстрая
   доставка с немедленным извещением получателя, а также рассылка
   сообщения группе получателей, что возможно далеко не во всех
   конфигурациях оконечных пользователей. Кроме того, технология
   предназначена для коммуникаций в глобальном масштабе, что
   накладывает необходимость использования соответствующих комплексных
   серверов, которые, тем не менее, нередко не решают проблемы -
   каждый пользователь сам должен вести список рассылки, если ему это
   надо.

   NNTP решает проблему групповой доставки (причем решает очень хорошо),
   но полностью теряет возможность немедленной доставки адресату
   (последний должен сам забирать сообщения с сервера) и опять-таки
   слишком глобален.

   Система ICQ (и ей подобные), казалось бы, решает проблему, но, как
   следует из ее глобальности (да, опять!), плохо приспособлена для
   посылки групповых сообщений - нет централизации, каждый пользователь
   должен настраивать такой список себе самостоятельно.

   Система чата IRC, как и программы для локальной сети на сходном
   принципе, не "страдает" глобальностью и в то же время предоставляет
   пользователю удобный механизм отправки сообщений группе адресатов -
   об этом заботится сервер. Однако IRC, хотя и полезен в своей нише,
   имеет большой выбор разнообразных программ и хорошо отлажен за свою
   долгую историю, имеет ряд недостатков, что вызвало появление на свет
   целого ряда программ, предназначенных для чата именно в условиях
   локальной (часто домашней) сети.

   Программы же типа TCPSender (пункт 2, а также некоторые программы
   для локальной сети (например, VyPress Chat), предоставляющие
   пользователям интерфейс, похожий на IRC) построены по технологии
   сканирования сети каждым компьютером, пользователь которого
   намеревается принять участие в общении. В результате по мере
   увеличения размеров сети стремительно (нередко в квадратичной
   зависимости от числа компьютеров в сети) увеличивается нагрузка на
   сетевое оборудование, а пользователи начинают все чаще получать
   недостоверную либо устаревшую информации о присутствии в сети
   других пользователей. Далее начинает сказываться и бедная
   функциональность (например, отсутствие фильтрации и сортировки
   сообщений по степени важности и т.п.). Если же сеть разбросана по
   нескольким сегментам с маршрутизацией между ними, картина
   становится еще более удручающей. Использование "продвинутых"
   технологий, скажем, IP multicast, в этих случаях не спасает ситуацию,
   поскольку требует корректной настройки всех затрагиваемых
   маршрутизаторов (с предотвращением смешения двух разных "ареалов"
   общения, если таковые есть - под групповой адрес подпадут компьютеры
   в обоих). Кроме того, multicast всё равно не дает гарантий
   надежной доставки сообщений, поэтому такие программы для надежных
   приватных коммуникаций все равно вынуждены использовать TCP
   (решением могло бы быть использование протокола PGM [RFC 3208],
   но он, к сожалению, так и не вышел из статуса экспериментального).

   Все системы чата, включая IRC, однако, обладают общим фундаментальным
   свойством, исходящим из самой природы чата - предполагается очень
   быстрый обмен короткими фразами в течение продолжительного времени,
   что нередко не подходит - требуется послать не очень короткое
   сообщение (например "оставить записку"), причем лишь время от
   времени. Чат требует от пользователя реакции в реальном времени,
   не оставляя времени на долгие раздумья, вынуждая писать короткие
   (обычно однострочные) фразы, и практически мешает (во всяком случае,
   сделать нормой) писать длинные рассуждения или вставлять длинные
   цитаты текста. Это только усугубляется с ростом числа пользователей
   на одном канале - что, если разговор начнет вести одновременно
   большое число групп людей? В результате даже в крупных IRC-сетях
   количество человек на одном канале очень редко переваливает за сотню.
   Во многих случаях подходящим решением является смена парадигмы -
   вместо чата использовать сообщения относительно большой длины
   (сравнительно с типичной длиной строк в чатах). Таким образом,
   общение теряет интерактивность, и пользователь получает возможность
   заниматься своим делом, не отвлекаясь на немедленный ответ (или даже
   просмотр) на пришедшие сообщения, если ему это не нужно. Отпадает
   необходимость быстрого ответа на сообщение, вместо этого оно может
   редактироваться сколь угодно долго (конечно, в разумных пределах).
   Соответственно, инициатива переходит к пользователю, самостоятельно
   планирующему свое время, от его собеседников, вольно или невольно
   принуждавших его к реагированию. Предполагается, что данная модель,
   эдакий "гибрид" ICQ, NNTP (и частично e-mail с IRC), будет во многих
   случаях предпочтительнее модели одновременного чата многих
   пользователей. Эта концепция и легла в основу проекта TheSender.

   Разумеется, существуют другие системы, позволяющие реализовать
   подобные концепции. Среди таковых можно назвать VyPress Messenger
   и Jabber [XMPP]. Первый, хотя и реализует почти все требования
   к протоколу, является проприетарным продуктом с закрытым
   протоколом. Второй же, хотя и является открытым с возможностями
   расширения, по-прежнему ориентирован на глобальные коммуникации
   (использование для адресации глобальной системы DNS). Немаловажно,
   что структура использованной основы протокола (XML) предполагает
   достаточно большую избыточность трафика (текстовый, а не бинарный,
   протокол плюс избыточность, имманентно присущая XML) и повышенные
   затраты ресурсов на его обработку. Кроме того, он построен на строгой
   клиент-серверной модели с обязательным использованием потокового
   транспортного протокола (TCP), что делает невозможным применение
   UDP для обеспечения требований автоматической настройки и работы
   в бессерверном режиме. Поэтому, с учетом всех требований, было
   принято решение создать новый бинарный протокол.

1.3. Назначение.

   Проект TheSender является попыткой разработать пакет программ,
   свободных от вышеперечисленных недостатков, базируясь на модели
   сообщений вместо чата. Проект основывается на открытом протоколе
   (в отличие от закрытых коммерческих аналогов), что в принципе
   позволяет любому разработать на его основе собственную устраивающую
   его программу, способную взаимодействовать с любыми другими
   программами, работающими по протоколу TheSender.

   Протокол TheSender предназначен для обеспечения возможности
   взаимодействия этих программ в локальных сетях, использующих стек
   протоколов TCP/IP.

1.4. Об этом документе.

   Данный документ является спецификацией поведения, требуемого от
   любой программы, использующей протокол TheSender, как при
   взаимодействии с пользователем (основные моменты), так и при
   взаимодействии с другими программами по сети.

   Оставшаяся часть этого раздела (секция 1.4) посвящена основным
   требованиям к функциональным возможностям протокола - перечню
   необходимых функций, которые должна выполнять любая программа пакета
   TheSender. Раздел 2 дает общее представление о взаимодействии и
   алгоритмах работы программ, использующих протокол TheSender. В
   разделе 3 описываются структуры данных, используемые протоколом.
   Раздел 4 представляет собой справочник, в котором детализируются
   и конкретизируются команды протокола без учета общей картины
   взаимодействия. Каждый раздел предполагает некоторое знакомство с
   другими разделами, что выражается, в частности, в использовании
   названий команд, структур и их полей (например, CM_NOOP) во всех
   разделах, а не только в том, где данное понятие описывается
   подробно. Поэтому реализацию лучше начинать, предварительно
   ознакомившись с документом целиком, и потом проходить по каждому
   разделу как по справочнику.


2. ФИЛОСОФИЯ (ОБЩИЕ ПРИНЦИПЫ).

2.1. Типографские соглашения.

2.1.1. Уровни требований.

   В данном документе используется стандартная система обозначения
   уровней требований ключевыми словами в соответствии с [RFC 2119].

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119.

   Однако, поскольку данный документ написан на русском языке, в нем
   используются русские эквиваленты данных слов. Таблица соответствия
   приведена ниже. Следует также учесть, что, хотя обычно данные
   ключевые слова пишутся заглавными буквами для отчетливости, в
   некоторых случаях из соображений удобочитаемости это может не
   выполняться; кроме того, следует учитывать разные грамматические
   формы, характерные для русского языка.

   Английский вариант  Русский вариант   Значение

   1. MUST             ДОЛЖЕН            Данное слово означает,
      SHALL            ОБЯЗАН            что определение является
      REQUIRED         ТРЕБУЕТСЯ         абсолютным требованием
                                         спецификации.

   2. MUST NOT         ТРЕБУЕТСЯ НЕ      Данное слово означает,
      SHALL NOT        НЕ ДОЛЖЕН         что определение является
                       ДОЛЖЕН НЕ         абсолютным запрещением
                                         спецификации.

   3. SHOULD           СЛЕДУЕТ           Данное слово означает, что
      RECOMMENDED      РЕКОМЕНДУЕТСЯ     в некоторых условиях могут
                                         существовать очень веские
                                         причины для невыполнения
                                         требования, но должны быть
                                         поняты и тщательно взвешены
                                         все причины, прежде чем
                                         выбрать путь, отличный от
                                         указанного под данной меткой.

   4. SHOULD NOT       НЕ СЛЕДУЕТ        Данная фраза означает, что
      NOT RECOMMENDED  НЕ РЕКОМЕНДУЕТСЯ  в некоторых условиях могут
                                         существовать веские доводы
                                         в пользу приемлемости или
                                         даже полезности описанного
                                         поведения, однако должны
                                         быть поняты и тщательно
                                         взвешены все причины, прежде
                                         чем реализовывать поведение,
                                         описанное под данной меткой.

   5. MAY              МОЖЕТ             Данное слово означает, что
      OPTIONAL         ОПЦИОНАЛЕН        описываемое под данной меткой
                                         полностью опционально. Один
                                         производитель может включить
                                         в свой продукт описываемую
                                         возможность, тогда как другой
                                         может принять решение не
                                         включать в свой продукт такую
                                         функциональность. Однако же,
                                         реализация со включенной
                                         такой возможностью ОБЯЗАНА
                                         быть готовой к взаимодействию
                                         с реализацией, в которой
                                         данная возможность отсутствует
                                         - хотя и с ограниченной
                                         функциональностью. И наоборот:
                                         реализация с отсутствующей
                                         возможностью ОБЯЗАНА быть
                                         готовой к полноценному
                                         взаимодействию с реализацией,
                                         в которой данная возможность
                                         наличествует, за исключением
                                         собственно описываемой
                                         возможности.

2.1.2. Нотация.

   В данном документе термины "байт" и "октет" употребляются наравне и
   обозначают 8-битовую порцию данных. Кроме того, используются также
   "слово" и "двойное слово" (и т.д.), означающие, соответственно,
   2 байта и 4 байта. В целях максимальной совместимости и переносимости
   все данные структур протокола (слова, двойные слова и т.д.)
   передаются в т.н. сетевом порядке байт (старший байт первым), в связи
   с чем приложения должны использовать для преобразования в
   локальный порядок байт функции вида ntohl(3), ntohs(3) и т.п. (либо
   их аналоги).

   Выражение вида "x^i" означает, что i является верхним индексом для x
   (в частности, это может означать "x в степени i"). Аналогично,
   в выражении "x_i" i является нижним индексом для x (в случае массивов
   может применяться также нотация "x[i]"). Шестнадцатиричные числа
   записываются в нотации языка Си (например, 0x68a2), кроме некоторых
   специально оговоренных случаев.

   Поля структур, составленные из нескольких английских слов, пишутся
   слитно, в нижнем регистре, с выделением заглавными буквами первых
   букв соответствующих слов, например, "MyFieldName". Константы
   протокола пишутся всегда целиком в верхнем регистре, с отделением
   значащих частей (обычно слов или сокращения типа) символом
   подчеркивания, например "CM_CONSTANT_NAME". Поля структур иногда
   могут быть указаны полностью, с указанием "пути" в имени структуры,
   в стандартной нотации языка Си, например, "BigStruct.SubRec.MyField".
   В некоторых случаях, когда именуемую сущность можно считать и
   константой, и именем поля (например, подполе флага в поле флагов
   или константа как битовая маска флага в поле флагов), используется
   более подходящий по смыслу вариант.

   Диаграммы передаваемых по сети структур выполнены в соответствии с
   [RFC 1700], с добавлением по правой границе смещения в байтах от
   начала структуры. Так же, в некоторых случаях в описании в тексте
   используется противоположный порядок битов, когда самым младшим
   является бит 0 (в соответствии со степенями двойки).

   Все поля, помеченные в форматах структур данных как зарезервированные
   (RESERVED), ДОЛЖНЫ инициализироваться нулями при отправке, и их
   значение ДОЛЖНО игнорироваться при получении. Кроме того, при
   пересылке промежуточными узлами, содержимое зарезервированных полей
   НЕ ДОЛЖНО изменяться, в целях обеспечения возможности коммуникации
   узлов, использующих более новую версию протокла по сравнению с
   промеждуточным узлом. Также следует отметить, что во многих полях
   комбинации из всех нулей или всех единиц часто являются
   зарезервированными, возможно, несущими специальное значение.

   Текстовая нотация базовых элементов протокола (например, NodeID)
   рассматривается в соответствующих разделах.

   Фразы, печатаемые в квадратных скобках, [вроде вот этой,] означают
   (по аналогии с традицией, принятой в некоторых видах документации),
   что употребление фразы в данном контексте полностью опционально, то
   есть предложение может быть прочитано как без части в квадратных
   скобках, так и вместе с нею. Также в квадратных скобках даются
   ссылки на литературу, например [RFC 793] на соответствующий документ,
   указанный в разделе "Ссылки".

2.2. Среда действия и базовые понятия.

   Программы семейства TheSender взаимодействуют между собой в сетях,
   использующих стек протоколов TCP/IP. Однако, они не используют
   напрямую IP-адреса и порты, вместо этого выделяется понятие "узел"
   как объект сети взаимодействующих друг с другом программ TheSender,
   и в качестве адреса объекта в такой сети используется структура
   NodeID - соответственно, каждый объект имеет свой уникальный NodeID.
   Узел TheSender не есть то же самое, что хост TCP/IP, поскольку на
   хосте может быть запущено несколько программ TheSender, и каждая
   может являться отдельным узлом TheSender (в дальнейшем просто узел).

   Каждый клиент и сервер имеет свой NodeID, в котором указано, является
   ли данный узел клиентом или сервером, однако, сверх того, выделяется
   еще один тип (тоже однозначно идентифицируемый по биту NodeID) - а
   именно групповой NodeID, являющийся обозначением некоего множества
   обычных узлов TheSender.

   TheSender предназначен прежде всего для обмена сообщениями между
   пользователями, и каждому сообщению присваивается, в свою очередь,
   уникальный идентификатор MsgID, состоящий из двух полей: NodeID
   узла, создавшего это сообщение, и серийного номера SerNum сообщения
   для этого узла. Уникальность MsgID обеспечивается уникальностью
   SerNum, который не должен повторяться в течение как минимум 48
   суток. Конкретный метод генерации серийного номера оставляется
   на усмотрение реализатора.

   TheSender использует предоставляемый TCP (порт по умолчанию 9426)
   надежный сервис потоковой передачи данных, и самостоятельно делит
   поток байт на записи переменной длины - фреймы (frame, кадр). Все
   данные протокола всегда инкапсулируются во фреймы. Каждый фрейм
   снабжен заголовком, в котором присутствуют, помимо прочих, поля
   сигнатуры протокола, длины данных фрейма, NodeID и собственно
   команды, подаваемой удаленной стороне этим фреймом. Каждая сторона
   постоянно проверяет длину данных (фреймы следуют друг за другом без
   пропусков) и ожидает увидеть корректную сигнатуру на своем месте;
   в случае несовпадения сигнатуры пришедшего фрейма с корректной
   (потери синхронизации), принявшая фрейм сторона ДОЛЖНА немедленно
   закрыть соединение.

   Для многих операций протокола не имеет значения, какая из сторон
   клиент, а какая сервер (или обе могут быть клиентами) - важно лишь,
   кто инициировал соединение (для некоторых же операций вообще не
   важно, кто есть кто). Поэтому одна из сторон обозначается как В
   (вызывающий), а другая как О (отвечающий).

   Одной из базовых структур протокола, помимо собственно сообщения и
   его заголовка, является NodeInfo - структура информации о узле,
   содержащая, кроме прочего, информацию о пользователе, возможности
   узла, различные флаги. Определена также структура Presence, в
   которой содержится IP-адрес и порт узла, статус доступности для
   сообщений.
      
   Структуры NodeInfo для каждого узла поддерживаются сервером, и
   каждый клиент может запросить их у сервера все или часть, для
   выбранных NodeID'ов. Структуры NodeInfo и Presence являются базовым
   средством определения возможности коммуникации клиентов между собой.

   Таким образом, сеть узлов TheSender, внутри которой и должны
   выполняться требования уникальности NodeID, MsgID и т.д.,
   определяется как связный неориентированный граф, вершинами которого
   являются узлы TCP/IP c запущенными программами пакета TheSender,
   а ребрами - TCP-соединения (точнее, возможность TCP-соединения),
   причем во всех вершинах графа существует возможность получения
   структур NodeInfo и Presence для любой вершины графа. Поскольку
   граф не обязан быть полносвязным, коммуникация узла с любым другим
   может быть достигнута путем передачи данных через промежуточные узлы
   (сервера). Поэтому понятие "соединение" трактуется в более широком
   смысле, нежели просто соединение TCP/IP - оно рассматривается как
   любой поток данных (обладающий свойствами TCP-соединения -
   надежностью и т.д., но необязательно являющийся непрерывным потоком
   байт - это может быть последовательность дейтаграмм) между узлами,
   т.е. путь в графе. Вводится также понятие "основное соединение"
   (синонимы: "прямое", "базовое", "несущее") - это TCP-соединение
   между узлами, т.е. одно ребро графа.

   Помимо служебных операций и собственно передачи сообщений (основного
   своего предназначения), протокол позволяет пересылать между узлами
   дейтаграммы произвольного формата (они инкапсулируются в основное
   соединение между узлами). Это позволяет теоретически неограниченно
   расширять возможности взаимодействия между узлами. Подробно данная
   возможность будет рассмотрена в одном из нижеследующих разделов.

   В документе также используются понятия "локальная сторона" (self),
   означающее рассматриваемый узел, создающий и отправляющий фреймы,
   и "удаленная сторона" (peer) - узел на другой стороне соединения,
   с которым взаимодействует локальная сторона.

2.3. Соединение между двумя узлами.

2.3.1. Фреймы - детализация.

   Как уже было сказано, все данные в соединении передаются во фреймах,
   и только в них, промежутков между фреймами не существует, так как
   это приведет к потере синхронизации. Каждый фрейм снабжен заголовком,
   в котором, помимо сигнатуры и версии протокола, содержатся поля
   флагов (модифицирующие интерпретацию данного фрейма) и команды.
   Локальная сторона помещает в поле CmdReply команду, которую должна
   выполнить удаленная сторона, а в поле данных фрейма - "аргументы"
   команды. Удаленная сторона обрабатывает фрейм, выполняет нужные
   действия и посылает ответный фрейм, в котором стоит флаг-признак
   ответа на команду, а поле CmdReply установлено в один из возможных
   кодов ответа, индицирующий результат выполнения команды (в поле
   данных, соответственно, - возвращаемые в ответ на команду данные).

   Протокол TheSender - асинхронный. Это значит, что узлы, участвующие
   в соединении, одновременно могут выполнять несколько операций, и
   узел, отправляющий команды, может не ждать получения ответа на
   посланную команду, а сразу слать следующую. Ответы на команды
   ДОЛЖНЫ возвращаться в том же порядке, в котором поступали команды,
   поэтому существует возможность легкого различения, к какой команде
   относится возвращенный ответ.

   Не каждая команда протокола подразумевает получение ответа. Например,
   к таковым относится команда сообщения об ошибочном фрейме, или же
   команда передачи нового значения статуса доступности пользователя
   для сообщений. В целях упрощения реализации команды разделены на
   два типа - на одни ответ всегда обязателен, на другие же ответ
   запрещен. Команды, не требующие ответа, могут спокойно посылаться
   в любой последовательности между фреймами с обычными командами и
   фреймами с ответами (главное, чтобы для обычных команд соблюдалась
   строгая последовательность ответов, указанная выше). Иногда, впрочем,
   команда без ответа может этот ответ всё же потребовать, однако,
   поскольку такие случаи относительно редки, в описанную простую схему
   не вводятся исключения в виде команд с необязательным ответом (как в
   IRC), а для уведомления об ошибке применяется специальная безответная
   команда CM_ERROR.

2.3.2. Установление и завершение прямого соединения.

   Обычно узел О прослушивает TCP-порт 9426, и узел В устанавливает с
   ним соединение. Сразу по приёму соединения узел О выдает команду
   CM_ALIVE, в ответ на которую узел В также выдает CM_ALIVE. В
   результате оба узла знают NodeID друг друга (могут удостовериться,
   что попали туда) и готовы к обработке команд друг от друга. Из
   этой схемы возможны 2 исключения: узел О может выдать CM_ERROR с
   извещением, например, о недостатке ресурсов на обслуживание
   соединения, и узел В в ответ на CM_ALIVE может выдать команду
   CM_REGISTER, в случае, если О - сервер, а В - новый узел, еще не
   имеющий собственного NodeID (который, таким образом, не может быть
   сообщен в CM_ALIVE).

   Сразу после обмена CM_ALIVE возможна опциональная фаза авторизации,
   если узлам важна их безопасность (например, в корпоративной сети,
   или сервер может потребовать авторизоваться привилегированный узел
   в домашней сети, не требуя авторизации от обычных пользователей).
   Первым команду CM_AUTH должен выдать узел О - если от него поступила
   любая другая команда, считается, что авторизации не будет. Впрочем,
   возможна отложенная авторизация, а также любое число повторов
   авторизации за соединение (для предотвращения "похищения"
   TCP-соединения атакой "человеком посередине"). В отсутствии
   авторизации реализации МОГУТ отказываться выполнять некое
   подмножество команд (определяется настройками) с возвратом ошибки
   RE_EPERM. Если узел О желает уведомить В, что не следует ждать
   авторизации, он может выдать, например, CM_TIME.

   Далее идет нормальный обмен командами, определяемый целью соединения,
   вплоть до явного завершения соединения в результате ошибки или
   нормального прекращения соединения командой CM_QUIT. Серверу
   также СЛЕДУЕТ закрыть соединение, если клиент отправил команду
   CM_PRESENCE со статусом, смененным на Offline (кроме того, сервер
   ДОЛЖЕН сменить статус на Offline и разослать извещения об этом при
   любой потере соединения с клиентом).

   В процессе обмена командами нередко возникает ситуация (типичная для
   случая соединения клиента с сервером, продолжающегося время
   нахождения клиента в сети), когда обеим сторонам не требуется
   посылать команды друг другу в течение длительного времени (например,
   вышележащие приложения двух узлов обмениваются дейтаграммами довольно
   редко). В этом случае, при необходимости поддержки соединения,
   сторона, не получавшая от другой стороны данных в течение 60 секунд,
   ДОЛЖНА отправить CM_ALIVE, и ожидать прихода ответного CM_ALIVE
   еще не более 60 секунд - в противном случае считается, что соединение
   разорвалось.

2.4. Взаимодействие клиента и сервера.

2.4.1. Ограничение на команды.

   Часть команд имеет смысл только при взаимодействии клиента с
   сервером, а не двух клиентов между собой. Прием некоторых их них от
   удаленной стороны клиенту не требуется реализовывать вообще
   (CM_LISTGROUPS, CM_SETNODEINFO, CM_SETPRIVINFO, CM_REGISTER), другие
   же следует принимать только от сервера (CM_JOIN, CM_KICK, CM_LEAVE,
   CM_SENDMSG).

   Смысл обеспечения возможности прямого соединения клиентов между
   собой - снижение нагрузки на сервер, когда это возможно (режим
   клиента) и обеспечение конфиденциальности (сообщения проходят не
   через сервер, а напрямую, возможно, по более защищенному каналу).

   Сервер, однако, ДОЛЖЕН принимать и пересылать любые сообщения и
   дейтаграммы, принимаемые им от клиента, хотя клиенту СЛЕДУЕТ при
   наличии прямого соединения с целевым узлом маршрутизировать
   направляемые ему сообщения и дейтаграммы по этому соединению, а не
   через сервер.

2.4.2. Установка и завершение соединения с сервером.

   Клиент считается присутствующим в сети всё время, пока он
   поддерживает соединение с сервером. Поэтому при установлении им
   соединения с сервером ("выходе в онлайн") должны быть проделаны
   некоторые дополнительные действия. После фазы аутентификации
   клиенту СЛЕДУЕТ запросить свою структуру NodeInfo (возможно, она
   изменилась, если клиент в результате административных политик был
   удален или добавлен в одну или несколько серверных групп), и, быть
   может, изменить её перед анонсированием своего выхода в сеть. Затем
   клиенту следует проверить структуры NodeInfo для тех групп, в которых
   он состоит (все запросы NodeInfo рекомендуется проводить командой
   CM_GETNINFO_IMS), после чего он ДОЛЖЕН одной или несколькими
   командами CM_GETPRESENCE получить текущий статус всех узлов, состояние
   которых он будет отображать в интерфейсе пользователя (обычно это
   все узлы всех групп, в которых он состоит). Клиент может также
   послать другие команды, перед тем, как наконец выдать CM_PRESENCE
   серверу со своим текущим статусом - с этого момента клиент считается
   официально "в онлайне", и сервер начинает рассылать уведомления о
   нём. Клиент также может запросить у сервера список сообщений для
   себя командой CM_LISTMSGS, и, выбрав MsgID сообщений, которые пришли
   за время отсутствия клиента в сети, запросить их соответствующим
   числом команд CM_GETMSG.

   Завершение соединения производится командой CM_QUIT от клиента
   (хотя сервер должен поддерживать и смену статуса на Offline). Перед
   завершением соединения клиенту рекомендуется узнать время на сервере
   командой CM_TIME, для использования этого значения при установлении
   соединения в следующий раз в командах CM_GETNINFO_IMS.

2.4.3. Установленное соединение.

   Протокол TheSender реализует в ограниченном виде оба метода получения
   статуса присутствия узла, описанные в [RFC 2778]. Любой узел в любой
   момент может запросить структуру Presence другого узла. Кроме того,
   любой узел A всегда считается подписанным на уведомления о смене
   статуса любого узла B, входящего в любую из групп, в которую входит
   A. Другие методы обеспечения подписки не предусмотрены (узел должен
   периодически опрашивать состояние интересующих его узлов вне групп,
   если это действительно ему нужно).

   Сервер МОЖЕТ заменить информацию об адресах в структуре Presence
   клиента, как описано в разделе 3.7.1 - в этом случае он уведомляет
   клиента об этом посылкой ему CM_PRESENCE с измененной структурой.
   То же происходит и при определении, что соединение с клиентом
   невозможно, и он работает в режиме "только через сервер", и т.д.
   Уведомляются и остальные подписанные клиенты.

   Клиенты ДОЛЖНЫ быть готовы получать от сервера уведомления Presence
   от сервера, не отличающиеся никакими полями, или только флагами,
   поскольку сервер ДОЛЖЕН разослать всем уведомление, например, об
   обновлении структуры NodeInfo, и т.п.

2.5. Группы.

   Членство в группах - постоянное, до явного выхода клиента из группы
   (самостоятельно или командой от оператора группы). Поэтому информация
   о членстве в группах сохраняется в структурах NodeInfo. При изменении
   членства в группе производится обновление структур NodeInfo, как
   описано в разделе 4.3.7, и структуры Presence c флагом обновления
   NodeInfo НЕ рассылаются, с целью экономии трафика на перезапросах
   NodeInfo. Следует отметить, что команды CM_JOIN, CM_LEAVE и CM_KICK
   по этой причине рассылаются всем узлам как затрагиваемой группы, так
   и всех групп, в которой состоит клиент, хотя это их напрямую не
   касается.

   В описаниях некоторых структур можно встретить упоминание "группы
   по умолчанию" узла. Её интерпретация полностью возлагается на
   реализацию (например, сообщениям от узлов из нее возможно присвоение
   большего приоритета) и не влияет на работу протокола (обрабатывается
   так же, как и любая другая группа), за исключением сохранения её
   значения (порядка в списке групп) для структуры NodeInfo узла.

   В разделе 3.1.1 приведены значения NodeID специальных групп. Они
   не имеют структур NodeInfo, могут иметь произвольное количество
   членов и предназначены только как адрес назначения. Группа
   глобальных сообщений включает в себя все узлы в сети. Доступ
   на отправку к этой группе СЛЕДУЕТ ограничить; механизм выделения
   прав здесь, однако, не оговаривается, и зависит от реализации.

   Существует так же группа глобальных сообщений, членство в которой
   свободное - к ней может присоединиться и покинуть ее любой клиент.
   Она создана с целью обеспечить существование группы, размер которой
   не лимитирован стандартным количеством в 16350 узлов, а также
   для разрешения простым пользователям отправлять сообщения "почти"
   всей сети (что запрещено им в случае обычной группы глобальных
   сообщений). Запрещать отправку сообщений в эту группу НЕ СЛЕДУЕТ,
   за исключением случаев ограничения флуда. Членство пользователя в
   этой группе указывается сброшенным флагом NF_NOEXTMSG в структуре
   NodeInfo узла.

2.6. Сообщения.

   Сообщения являются тем, ради чего создавался протокол TheSender.
   Сообщения могут быть переданы, запрошены, ожидать доставки узлу,
   который в настоящий момент выключен. Каждое сообщение имеет свой
   идентификатор - MsgID, который уникален в течение времени жизни
   сообщения (любой узел ДОЛЖЕН удалять сообщения, срок жизни которых
   истёк, то есть превысил 48 суток). Если узлу передается сообщение,
   MsgID которого совпадает с таковым у одного из сообщений, которое
   узел уже принимал ранее (имеется в базе сообщений), узел ДОЛЖЕН
   принять сообщение и затем молча его проигнорировать.

   Срок хранения сообщений на сервере НЕ ДОЛЖЕН быть менее суток,
   конкретное же значение определяется настройками (административной
   политикой) и, к примеру, может быть разным для разных групп.
   Данные о полученных MsgID любому узлу СЛЕДУЕТ хранить в течение
   всего срока жизни сообщения.

   Узлы могут применять свои настройки к приему разного типа сообщений,
   например, сервер (или обыкновенный узел при прямом соединении) может
   возвратить ошибку RE_EPERM узлу, который попытался отправить
   сообщение с приоритетом 3 (критическим), в то время как ему это не
   разрешено. Вообще, любой узел ДОЛЖЕН принимать сообщения с
   приоритетом 3 только от сервера, прием таких сообщений от других
   узлов оставляется на усмотрение пользователя.

2.7. Дополнительные возможности: дейтаграммы.

   Одним из требований к функциональности, которое должен реализовать
   протокол TheSender, является расширяемость. Следует предусмотреть
   возможность передачи между узлами не только сообщений, но и других
   данных, причем заранее неизвестного формата. Это достигается путем
   введения дейтаграмм, пакетов с определенным заголовком, структура
   данных которых не имеет значения для протокола, а важна лишь для
   программного обеспечения узлов, обменивающимися этими дейтаграммами.
   Подробно дейтаграммы рассмотрены в разделе 3.5.
   
   Дейтаграммы универсальны, и на них базируется поддержка чата и
   передачи файлов, двух наиболее востребованных сервисов, которые
   ДОЛЖНА поддерживать каждая реализация TheSender. Формат данных
   дейтаграмм этих сервисов описан в Приложении B.

   Следует отметить, что дейтаграммы могут передаваться только между
   включенными в сеть узлами. Для них, как и для сообщений, необходимо
   предусмотреть возможность ограничения скорости посылки во избежание
   "флуда" злонамеренных клиентов. Сервер может посылать дейтаграммы
   с кодом source quench, если скорость посылки превышает некоторое
   сконфигурированное администратором значение (РЕКОМЕНДУЕТСЯ, однако,
   обеспечивать минимальную скорость в 1 килобайт в секунду), и
   имеет право прекратить доставку дейтаграмм для узла (с возвратом
   кода административного запрещения) через какое-то время и несколько
   посылок кода source quench (следует учесть, что ввиду задержек в
   сети, узел не может сбросить скорость сразу же).

2.8. Работа сети в целом.

2.8.1. Нормальный режим.

   Сеть узлов TheSender функционирует как единое целое под управлением
   сервера. Сервер полностью управляет доставкой групповых сообщений и
   видимостью клиентов друг другу, делая возможным использование
   "невидимого" режима. Если один узел становится невидимым для другого,
   сервер сообщает ему, что первый узел перешел в Offline. Узел может
   контролировать свою видимость другим узлам установкой соответствующих
   полей в своей структуре PrivInfo. Реализаторам серверов необходимо
   позаботиться о корректной рассылке уведомлений о смене статуса всем
   затрагиваемым узлам, с целью недопущения "утечки" информации,
   свидетельствующей о том, что узел на самом деле находится не в
   Offline и/или раскрытия данных о его IP-адресе и порту. Реализаторам
   клиентов следует позаботиться о том, чтобы не допускать попыток
   коммуникации узла с другими узлами, которые считают его находящимся
   в Offline, поскольку в целях безопасности узлам ТРЕБУЕТСЯ НЕ
   принимать соединения от узлов, находящихся в Offline.

   Можно обратить внимание, что нигде в спецификации протокола TheSender
   не запрещено иметь в сети более одного сервера. Это действительно
   так, и принципиально возможно иметь сеть серверов, связанную более
   сложной структурой, чем остовное дерево (spanning tree), ввиду того,
   что наличие у сообщений уникальных идентификаторов позволяет избежать
   дублирования передач и повысить эффективность. Текущая версия
   протокола, однако, не определяет точных механизмов взаимодействия
   нескольких серверов, и клиенты ведут себя так, как если бы всей
   информацией о сети ведал только один сервер, к которому они
   подключены, хотя ограничений на присутствие других в них быть
   не должно, и это в принципе уже может быть организовано внешними
   по отношению к протоколу средствами. Определение работы сети с
   несколькими серверами будет сделано в последующих версиях протокола.

2.8.2. Бессерверный режим и обнаружение сервера.

   Одной из важных характеристик протокола TheSender является
   отказоустойчивость. Сеть способна продолжить свою работу при отказе
   сервера. Достигается это использованием широковещательных
   UDP-дейтаграмм на порт 9426. Каждый узел, соединение которого с
   сервером разорвалось, переходит в бессерверный режим. В этом режиме
   он прослушивает порт 9426, ежеминутно посылает на локальный
   внутрисетевой широковещательный адрес UDP-дейтаграмму с размером
   данных 12 байт, содержащую фрейм с командой CM_ALIVE. Предполагается,
   что переход в бессерверный режим произошел в результате отказа
   сервера, и поэтому каждый узел уже имеет актуальный список активных
   узлов. Прием дейтаграммы обновляет список: если такого узла не было,
   он добавляется туда (например, узел включился уже после отказа
   сервера). Если какой-либо узел пропустил две посылки CM_ALIVE подряд,
   то, если за это время с ним не было TCP-соединений, считается, что он
   выключился, и удаляется из списка.

   В бессерверном режиме доступные функции ограничены. Коммуникации
   ограничены только локальным широковещательным сегментом (в будущих
   версиях, возможно, будет добавлена поддержка IP Multicast). Не
   работает отправка широковещательных дейтаграмм, режим невидимости,
   запрещена аутентификация, игнорируются приоритеты сообщений, нет
   передачи структур Presence, т.к. IP-адреса известны из UDP, и т.д.
   Отправка групповых сообщений возможна только на специальный NodeID
   группы бессерверных сообщений, и выполняется узлом самостоятельно,
   последовательными TCP-подключениями к каждому узлу из списка. Тем
   не менее, несмотря на ограниченность функций, этого вполне достаточно
   для базовых функций коммуникаций протокола на то время, пока не будет
   восстановлен сервер.

   Выход из бессерверного режима производится по приёму сообщения
   CM_ALIVE с NodeID сервера. Сервер при включении отправляет такую
   UDP-дейтаграмму, клиенты её получают и узнают, что сервер стал
   доступен (если сервер находится в другой подсети, клиенту следует
   периодически (скажем, раз в минуту) повторять попытки TCP-подключения
   к нему); отправляет он её и при любом получении подобных
   широковещательных дейтаграмм (сервер ДОЛЖЕН прослушивать UDP-порт
   постоянно, клиенты же НЕ ДОЛЖНЫ прослушивать порт в обычном режиме).
   Это позволяет реализовать автоматическую настройку нового клиента на
   сервер, находящийся с ним в одной подсети: при первом включении он
   просто переходит в бессерверный режим, получает дейтаграмму от
   сервера, узнает его IP-адрес, соединяется и регистрируется.

   Реализаторам следует обратить внимание, что в текущей версии
   протокола по UDP могут передаваться только фреймы CM_ALIVE, все
   другие принятые данные следует игнорировать. Необходимо выполнять
   проверки на принятые NodeID - для предотвращения ситуаций, когда
   клиент будет пытаться соединиться с ложным сервером (авторизация
   в UDP-части протокола не предусмотрена). Кроме того, в сетях с
   высокими требованиями к безопасности бессерверный режим может
   быть административно запрещен вообще.


3. СПЕЦИФИКАЦИЯ ФОРМАТА.

3.1. Базовые элементы.

   Основные структуры протокола TheSender часто состоят из элементов,
   которые сами могут быть структурами. Встречаться они могут не
   единственный раз с разным назначением. Данный раздел описывает
   эти базовые "кирпичики" протокола.

3.1.1. NodeID.

   Это 4-байтовая структура, уникальным образом идентифицирующая
   узел TheSender (или их группу) в сети.

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |B|S|              Unique object address (number)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4

   Здесь B - флаг указания группы узлов (групповой адрес, если он равен
   единице), а S - указывает, что данный узел является не клиентом, а
   сервером (либо серверной группой). Оставшаяся часть представляет
   собой число, которое должно быть уникальным. При необходимости
   сортировки NodeID считается просто 32-битным беззнаковым числом
   (со старшими битами B и S).

   Стандартная нотация NodeID в читаемом человеком виде представляет
   собой особым образом записанную шестнадцатиричную нотацию NodeID,
   представленного как число (двойное слово), c дефисом, отделяющим
   слова, примеры: 805a-c6f9 или 30f5-4471.

   Существуют зарезервированные значения NodeID, которыми являются
   все комбинации с Unique object address, состоящим из всех нулей
   или единиц. Их значение:

   *  0000-0000  - "пустой" NodeID, так же обозначает самого себя
   *  03ff-ffff  - зарезервировано
   *  4000-0000  - зарезервировано
   *  7fff-ffff  - зарезервировано
   *  8000-0000  - группа по умолчанию для бессерверного режима
   *  bfff-ffff  - группа глобальных сообщений со свободным членством
   *  с000-0000  - специальная группа, все сервера сети
   *  ffff-ffff  - спецгруппа глобальных сообщений, все узлы всей сети

3.1.2. MsgID.

    Каждое сообщение в сети TheSender имеет свой уникальный
    идентификатор, отличающий его от любого другого сообщения - MsgID.
    MsgID используется в основном для целей запроса сообщения по его
    идентификатору и для предотвращения возможного приема дубликатов
    сообщений (поскольку два разных сообщения не могут иметь одинаковый
    MsgID, сообщения с одинаковым MsgID считаются дубликатами и могут
    отбрасываться при приеме, если обнаруживается, что у узла такое
    сообщение уже есть).

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |                            NodeID                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |                            SerNum                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8

   Здесь NodeID принадлежит узлу, создавшему сообщение (не может быть
   групповым). SerNum есть серийный номер сообщения (32-битовое число),
   он должен быть уникальным для данного узла в течение по крайней мере
   48 суток (таким образом, время жизни сообщения ограничвается 48
   сутками). Конкретный метод генерирования SerNum остается на
   усмотрение реализатора, требуется лишь его уникальность.

   Стандартное представление MsgID в читаемом человеком виде -
   "<" SerNum "@" NodeID ">" (SerNum представляется в шестнадцатиричном
   виде), примеры: <79b3a8e2@0058-3а26> или <095c6a13@4085-328d>.

   Специальным значением является нулевое: <00000000@0000-0000>,
   означающее пустой MsgID (его отсутствие). Данное значение может
   использоваться в некоторых полях (например, Msg.Reply).

3.1.3. Время.

   В протоколе TheSender используется единственное представление
   времени - в формате UnixTime. Это 32-битовое число, представляющее
   собой число секунд, прошедших с полночи 1 января 1970 года, UTC
   (т.е. реализации пользователей должны самостоятельно переводить
   время из/в UTC, учитывать летнее время и т.п.).

3.2. Формат фрейма и его заголовка.

   Фрейм представляет собой пакет данных переменной длины, снабженный
   заголовком фиксированной длины (8 байт). Данные (если есть) идут
   после заголовка, команда и длина данных указаны в заголовке.

   Формат фрейма изображен на рисунке:

       8 байт             от 0 до 65535 байт (поле Length)
         ^                              ^
     ___/ \___   ______________________/ \________________________
    /         \ /                                                 \
   +-----------+----------------.........................----------+
   |FrameHeader|             Frame Data (Optional)                 |
   +-----------+----------------.........................----------+

3.2.1. Заголовок фрейма.

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |                THS_MAGIC_NUMBER               |  Ver  | Flags |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |    RESERVED   |   CmdReply    |          DataLength           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8

   Описание полей заголовка фрейма:

   THS_MAGIC_NUMBER

      Сигнатура протокола ('магическое число'). Всегда равна строке
      'ThS' (три последовательных байта 0x54 0x68 0x53).

      В случае несовпадения сигнатуры в полученном фрейме локальная
      сторона ДОЛЖНА немедленно закрыть соединение, игнорировав этот
      фрейм, так как это означает потерю синхронизации потока данных
      и возможные серьезные ошибки в данных отправителя фрейма. По этой
      причине в протоколе не предусмотрено средств восстановления
      синхронизации.

   Ver

      Версия протокола, используемая данной стороной. Кодируется
      как версия минус 1, т.е., для текущей версии (1) поле должно
      равняться нулю.

      В случае различия версии локальная сторона ДОЛЖНА немедленно
      закрыть соединения, если она не поддерживает её (в будущем
      некоторые реализации могут включать поддержку предыдущих
      версий для совместимости).

   CmdReply

      Поле содержит номер команды протокола, либо, при соответствующем
      флаге, статусный код (код ошибки) на одну из предыдущих команд.
      Номера команд и ошибок рассматриваются в следующих разделах.

   Flags

      Поле флагов данного фрейма. Неопределенные значения считаются
      зарезервированными, должны быть равными нулю и игнорироваться
      при получении. Определенные в данный момент значения флагов
      (битовые маски операции AND):

      * FLG_ZEROLEN, 0x01

         Поле DataLength не указывает длину данных (фрейм состоит
         только из заголовка), а содержит сами данные, либо вообще
         игнорируется.

      * FLG_REPLY, 0x02

         В поле CmdReply содержится не команда, а код ответа на
         другую команду.

   DataLength

      Поле длины данных, следующих за заголовком фрейма, в октетах.
      В значение длины не входит длина заголовка фрейма. Длина фрейма
      ограничена только разрядностью поля длины, то есть может
      достигать полных 65535 байт.

      В случае, если установлен флаг FLG_ZEROLEN - длина поля данных
      равна нулю (фрейм состоит только из заголовка), сами данные
      (если есть для данной команды), 1 или 2 байта, помещаются в
      само поле DataLength. Первый байт данных помещается в старший
      байт, второй байт, если он есть, - в младший. Поддержка
      корректной обработки фреймов с установленным FLG_ZEROLEN
      ТРЕБУЕТСЯ при приёме фреймов. Использование такой "компрессии"
      данных с FLG_ZEROLEN при отправке не требуется, но РЕКОМЕНДУЕТСЯ
      (с целью уменьшения числа системных вызовов чтения данных из
      сети на принимающей стороне), за исключением случаев, когда
      из типа команды заранее неизвестно точное число байт (0, 1 или 2)
      в поле данных.

3.3. Структура информации об узле.

   Структура NodeInfo является основным источником информации об узле:
   в ней хранится имя хозяина, членство в группах и т.п.

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |            Length             |            RESERVED           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   | LocalReserved |     Flags     |            CodePage           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8
   |                          LastUpdTime                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 12
   |                            NodeID                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 16
   |                                                               |
   /                                                               /
   \                   Attributes (variable length)                \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

3.3.1. Описание полей.

   Length

      Полная длина структуры, включая фиксированный заголовок и все
      атрибуты.

   LocalReserved

      Поле зарезервировано для внутреннего использования программным
      обеспечением узла в своих целях и должно полностью игнорироваться
      при получении. Гарантируется, что поле не будет использовано в
      следующих версиях протокола для нужд самого протокола. Узлы могут
      использовать свои внутренние флаги в этом поле.

   Flags

      Поле флагов данного узла или группы. Подробнее рассмотрены ниже.

   CodePage

      Указывает кодовую страницу атрибутов, открывая возможность
      использовать в них родной язык пользователя. Также указывает
      кодовую страницу "по умолчанию" для сообщений с этого узла.
      Подробно рассмотрено в Приложении "Языки и кодовые страницы".

   LastUpdTime

      Время последнего изменения информации об узле. Введено с тем,
      чтобы клиенты могли кэшировать эту информацию (поскольку размер
      структуры может быть большим), обновляя её, только если время
      последнего изменения превышает таковое у локальной копии.

   NodeID

      NodeID узла, который описывает эта структура NodeInfo.

3.3.2. Описание флагов узла.

      Неопределенные значения флагов считаются зарезервированными,
      должны быть равными нулю и игнорироваться при получении.
      Определенные в данный момент значения флагов:

      * NF_NOEXTMSG, 0x01

         Отказ от получения внешних групповых сообщений. Для группы это
         означает, что сообщения, отправляемые группе, могут исходить
         только от членов группы (по умолчанию сообщение группе может
         отправить любой узел сети). Кроме сообщений, флаг влияет и на
         доставку групповых дейтаграмм. Для узла флаг NF_NOEXTMSG
         означает отказ от приёма сообщений, адресуемых группе
         глобальных сообщений свободного членства (NodeID bfff-ffff).

      * NF_PRIVATE, 0x02

         Означает приватную группу. Сервера ДОЛЖНЫ отвечать на запросы
         структуры NodeInfo приватной группы только её членам и узлам,
         перечисленным в соответствующем поле структуры PrivInfo.
         Присоединяться к приватной группе разрешено тоже только лишь
         узлам, перечисленным в соответствующем поле структуры PrivInfo
         (к "публичной" же группе по умолчанию может присоединиться
         любой узел). Приватность группы, однако, не означает, что узлы,
         в ней не состоящие, не могут отправить на неё сообщение -
         это определяется флагом NF_NOEXTMSG (и полями PrivInfo)
         независимо от приватности группы. Запросы сообщений по MsgID
         из приватной группы разрешены только для её членов. Флаг
         NF_PRIVATE имеет смысл только для группы, и должен
         игнорироваться для узла.

3.4. Заголовок сообщения.

   Сообщения являются основными данными, для передачи которых и
   создавался протокол TheSender. Структура сообщения достаточно сложна,
   сначала идет заголовок фиксированной длины, затем идут атрибуты,
   переменной длины, затем собственно текст сообщения, тоже переменной
   длины, и после этого еще могут следовать дополнительные данные
   (наличие/интерпретация зависит от атрибутов), также переменной
   длины.

   Формат фиксированного заголовка:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |           Length              |            HdrLen             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |         AddonDataOfs          |            CodePage           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8
   |                             Time                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 12
   |                             Flags                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 16
   |                           FromNodeID                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 20
   |                            ToNodeID                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 24
   |                                                               |
   |                            RESERVED                           |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 32
   |                                                               |
   |                             MsgID                             |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 40
   |                                                               |
   |                           Reply[0]                            |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 48
   |                                                               |
   |                           Reply[1]                            |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 56
   |                                                               |
   |                           Reply[2]                            |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 64
   |                                                               |
   |                           Reply[3]                            |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 72
   |                                                               |
   |                           Reply[4]                            |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 80
   |                                                               |
   /                                                               /
   \                  Attributes (variable length)                 \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                                                               /
   \                  MessageText (variable length)                \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                                                               /
   \         AddonData (variable length) - может отсутствовать     \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

3.4.1. Описание полей.

   Length

      Полная длина сообщения, вместе с заголовком, текстом, и, возможно,
      дополнительными данными.

   HdrLen

      Длина заголовка сообщения. Заголовок сообщения состоит из
      фиксированной части и атрибутов. Таким образом, данное поле
      фактически есть смещение текста сообщения от начала фиксированного
      заголовка (например, при длине атрибутов 20 поле HdrLen будет
      содержать 100).

   AddonDataOfs

      Смещение дополнительных данных сообщения. Дополнительные данные
      располагаются сразу после текста, в случае их отсутствия поле
      ДОЛЖНО содержать нулевое значение. Если дополнительные данные
      присутствуют, они идут сразу после текста (тогда поле фактически
      ограничивает длину текста) до конца сообщения (полная же длина
      сообщения известна из поля Msg.Lentgh, таким образом, в заголовке
      содержится информация о размере всех полей переменной длины).
      Например, при длине атрибутов 20 и длине текста сообщения 30
      (длина текста, кстати, ДОЛЖНА быть ненулевой, равно как и длина
      дополнительных данных, если они присутствуют), поле AddonDataOfs
      будет содержать 130. Интерпретация содержимого дополнительных
      данных производится по атрибутам.

   CodePage

      Указывает кодовую страницу текста и атрибутов сообщения, открывая
      возможность написания сообщений на родном языке пользователя.
      Подробно рассмотрено в Приложении "Языки и кодовые страницы".

   Time

      Время создания сообщения.

   FromNodeID

      NodeID отправителя сообщения. Не может быть групповым и/или
      специальным.

   ToNodeID

      NodeID основного получателя сообщения. Может быть групповым или
      групповым специальным NodeID.  В атрибутах могут быть указаны
      дополнительные получатели сообщения (см. раздел 3.6.3).

   MsgID

      Уникальный идентификатор MsgID данного сообщение. Поле ДОЛЖНО
      содержать ненулевой корректный MsgID (с NodeID узла-создателя).

   Reply, массив из 5 элементов

      Каждый элемент этого массива имеет тип MsgID. Назначение массива:
      хранение цепочки ответов на сообщения. При создании сообщения,
      являющегося ответом на другое сообщение, программное обеспечение
      узла ДОЛЖНО поместить в Reply[0] MsgID того сообщения, на
      которое данное является ответом. Если поле Reply[0] уже имеет
      ненулевое значение, это значение предварительно переписывается в
      элемент Reply[1], то же самое производится и с ним, и так
      далее, за исключением поля Reply[4], значение которого просто
      отбрасывается. Если сообщение является новым, а не ответом на
      какое-либо другое, то в Reply записывается нулевое значение.
      Таким образом, при создании абсолютно нового сообщения весь
      массив Reply заполняется нулями, а при ответе на сообщение
      алгоритм заключается в простом сдвиге пяти полей с MsgID по
      Reply[3] на размер MsgID вправо, на место массива MSG.Reply.

      Существуют разные мнения касательно целесообразности реализации
      системы ссылок ответов на сообщения-оригиналы, основное (прямое)
      применение которых (в NNTP) состоит в выстраивании цепочек
      ответов и выглядит слишком "тяжеловесным" для системы обмена
      малоценными (и обычно короткими) мгновенными сообщениями. Однако
      было принято решение о включении этой системы в протокол, так
      как заполнение этих полей не составит никакого труда для тех
      клиентов, которые их вообще никак не используют, и в то же время
      дает возможность любого использования желающими того клиентами,
      пусть даже оно будет заключаться, например, во всего лишь пометке
      для фильтрации всей нежелательной ветви обсуждения или простом
      запросе с сервера по MsgID предшествующих текущему сообщений в
      его ветви обсуждения (скажем, после случайного удаления).

3.4.2. Флаги сообщения.

   Группы битов в поле флагов рассматриваются как числа.

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |               |                 |T|R|R|C|B|D|T|           |PRI|
   | LocalReserved |     RESERVED    |C|R|R|F|L|N|T|  Format   |ORI|
   |               |                 |H|C|Q|M|T|P|Y|           |TY |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4

   Описание флагов, справа налево по диаграмме:

   MF_PRIORITY

     Приоритет сообщения. Значения:

     0 - Below normal: пониженной важности
     1 - Normal: нормальный приоритет, для обычных сообщений
     2 - Important: важное сообщение
     3 - Critical: критическое, сообщение требует немедленного внимания

     Большинство сообщений в сети имеют нормальный приоритет, но нередки
     и другие значения. Приоритет сообщений является частью механизма
     сортировки сообщений по важности со стороны сети.

     Программное обеспечение узла может выполнять функции сортировки
     сообщений по важности (scoring), исходя из их содержимого: по
     ключевым словам, отправителю, получателю и т.д. - причем поведение
     механизма сортировки обычно настраивается пользователем. Некоторые
     сообщения, не представляющие интереса, не показываются в режиме
     по умолчанию, другие молча убиваются, и потому не могут потревожить
     пользователя вообще, некоторые же сообщения, исключительной для
     пользователя важности, могут прервать его работу, даже если он
     включил (для всех остальных) режим, который не прерывал бы его
     текущую приоритетную программу.

     Однако эта часть механизма настраивается исключительно самим
     пользователем на его узле, и другие узлы никак не могут повлиять
     на его работу, поэтому вводятся приоритеты сообщений. Любой
     приоритет, отличающийся от нормального, ДОЛЖЕН быть каким-либо
     образом отмечен в пользовательском интерфейсе. Сообщения, имеющие
     приоритет 0 ("ниже нормального"), в настройке по умолчанию не
     показываются пользователю, хотя он специальными командами должен
     сохранить возможность их просмотра. Сообщения с приоритетами 2 и 3
     должны показываться всегда, возможно, с сортировкой - первыми
     показываются сообщения с этими приоритетами, потом все остальные.
     Приоритет 3 ("аварийный", "срочный") обычно применяется для
     административных оповещений - сообщений о событиях, требующих
     немедленного внимания пользователей. В настройке по умолчанию он
     должен приводить, например, к "всплыванию" окна программы на
     передний план даже при отключенной такой настройке для остальных
     сообщений (либо к другому аналогичному эффекту, в зависимости от
     устройства интерфейса пользователя в конкретной программе).

     При таких настройках (приоритет перекрывает внутренние правила),
     однако, возникает другая проблема - злоупотребления приоритетами
     с целью обхода правил сортировки и, например, заваливания
     пользователя "хулиганскими" сообщениями. Поэтому ограничивается
     использование приоритета 3 - узел может принять личное сообщение
     с таким приоритетом только напрямую от узла, которому это явно
     разрешено пользователем в настройках, либо от сервера. Сервер же
     может принять такое [групповое] сообщение только от узлов, также
     явно прописанных в его настройках. То есть, серверу/узлу СЛЕДУЕТ
     игнорировать (выдать соответствующую ошибку приема) сообщение с
     приоритетом 3, принятое от узла, которому таковое поведение явно
     или неявно запрещено.

     Вводится и еще одно правило, направленное на взаимодействие с
     внутренним механизмом сортировки по важности. Представим себе
     пользователя, который хочет видеть только важные сообщения. С
     этой целью он включает еще один механизм - понижения приоритета.
     То есть, до действия всех фильтров его узла, приоритет каждого
     входящего сообщения понижается на единицу, то есть, сообщения,
     имевшие приоритет 0, сразу же уничтожаются, обычные сообщения
     получают приоритет "ниже нормального", важные сообщения становятся
     обычными, срочные - просто важными. После этого вступают в действие
     фильтры пользователя, и они в принципе могут уничтожить вообще все
     сообщения - кроме тех, которые сейчас имеют приоритет 2, то есть
     срочных - цель достигнута (пользователь, однако, ДОЛЖЕН иметь
     в интерфейсе возможность при желании увидеть оригинальное значение
     приоритета сообщения). Кроме того, с целью ограничения сетевого
     хулиганства, администратор сервера может ввести дополнительные
     ограничения, вроде принудительного ограничения посылки сообщений
     злоупотреблявшим высоким приоритетом, однако это уже не требуется
     протоколом и выходит за его рамки, и поэтому здесь
     не рассматривается.

   MF_Format

      Формат текста сообщения. Подробно рассматривается в
      Приложении "Форматирование текста".
   
   MF_TTY

      Установленный флаг означает, что текст сообщения должен
      отображаться получателю моноширинным шрифтом, если тот имеет
      возможность отображения текста разными шрифтами. Флаг должен быть
      по умолчанию установлен при отправке узлами, работающими в режиме
      отображения только символов фиксированной ширины (консольные
      приложения, unix-терминалы) и по умолчанию сброшен узлами,
      отображающими текст в графическом режиме пропорциональным шрифтом,
      хотя программному обеспечению узла СЛЕДУЕТ давать возможность
      пользователю изменить значение флага для каждого создаваемого
      сообщения. Флаг предназначен для облегчения пользователю
      управления видом сообщения в случае, если формат текста (см. поле
      MF_FMT) не позволяет значительно изменять оформление текста
      (например, plain text), и позволяет сделать ручное выравнивание
      текста вне зависимости от различных пропорциональных шрифтов на
      системах отправителя и получателя. В случае, если используется
      сложный формат текста, несущий в себе информацию о шрифтах
      различных частей текста (например, RTF или HTML), и получатель в
      состоянии корректно отобразить это форматирование, флаг MF_TTY
      должен игнорироваться (если, однако, получатель распознает формат,
      но не в состоянии его правильно отобразить, MF_TTY по-прежнему
      используется в качестве подсказки о форматировании большей части
      текста).

   MF_DNP (Do Not Propagate)

      Сообщение является копией, само сообщение послано по другому
      маршруту. Пересылать это сообщение не требуется, только хранить
      в течение некоторого времени. Может использоваться, например, для
      увеличения надежности - узел отсылает сообщение напрямую, а копию
      оставляет на сервере, которую получатель может забрать с него
      после сбоя или случайного удаления.

   MF_BLT (Bulletin)

      Сообщение является "объявлением". Объявления отличаются от обычных
      сообщений тем, что клиентское программное обеспечение ДОЛЖНО
      не давать возможности пользователю удалить объявление до истечения
      срока, определяемого атрибутом AT_EXPIRE. Таким образом, однажды
      "вывешенное" объявление будет "висеть" вплоть до истечения срока
      жизни либо до явного "снятия" специальной служебной дейтаграммой,
      которая ДОЛЖНА обрабатываться клиентским программным обеспечением
      только от автора объявления, любого сервера или любого оператора
      группы. Флаг MF_BLT не имеет смысла в не-групповых сообщениях, а
      также в сообщениях с ненулевым массивом Msg.Reply (т.е. в ответах
      на другие сообщения), и ДОЛЖЕН игнорироваться в них. Приоритет
      объявлений игнорируется и всегда считается нормальным.
      Программному обеспечению узла СЛЕДУЕТ каким-либо образом отмечать
      в пользовательском интерфейсе, что сообщение является объявлением.

   MF_CFM (reading ConFirMation request)

      Затребовать с получателя квитанцию о прочтении сообщения.
      Программному обеспечению узла получателя СЛЕДУЕТ сгенерировать
      ответное сообщение-квитанцию о том, что пользователь прочитал
      данное сообщение. Квитанция НЕ ДОЛЖНА генерироваться в ответ на
      сообщение, адресованное на групповой NodeID. См. также флаг
      MF_RRC.

   MF_RRQ (return Receipt ReQuest)

      Затребовать с получателя квитанцию о доставке сообщения.
      Программное обеспечение узла получателя ДОЛЖНО сгенерировать
      ответное сообщение-квитанцию о том, что сообщение было успешно
      доставлено на узел получателя, в случае, если сообщение не было
      адресовано на групповой NodeID. Квитанцию СЛЕДУЕТ создать в
      случае, если сообщение было адресовано [в том числе] на групповой
      NodeID, однако см. также флаг MF_RRC.

   MF_RRC (Return ReCeipt)

      Флаг ДОЛЖЕН устанавливаться в том случае, если сообщение является
      квитанцией, генерируемой в ответ на флаги MF_RRQ или MF_CFM (кроме
      того, он не может быть установлен одновременно с ними, дабы
      избежать бесконечного переброса квитанциями в ответ на другие
      квитанции), причем при этом также должен быть установлен флаг
      MF_TCH. Квитанцию генерирует только узел получателя, то есть
      промежуточные или хранящие узлы (если таковые есть) не проверяют
      флаги запроса квитанции, если сообщение предназначено не им. Сама
      квитанция представляет собой произвольное текстовое сообщение (оно
      имеет значение лишь для человека), сообщающее о выполненном в
      ответ на флаг действии (например, могут приводиться начальные и
      конечные строки исходного сообщения). Кроме того,
      сообщение-квитанция не может иметь повышенный (2 или 3) приоритет.
      С точки зрения протокола, квитанция явлется нормальным сообщением
      (например, точно также обрабатывается Msg.Reply), однако
      программное обеспечение получателя квитанции может не представлять
      квитанции пользователю как обычные сообщения. Тем не менее, оно
      ДОЛЖНО иметь в пользовательском интерфейсе средства четкого
      информирования пользователя о квитанции. В случае, если исходное
      сообщение предназначалось на групповой NodeID, квитанция о
      доставке (к квитанциям о прочтении следующее неприменимо), вместо
      сообщения с флагом MF_RRC, ДОЛЖНА (а при негрупповом NodeID, но
      списке получателей (больше одного) - МОЖЕТ) быть отправлена
      служебная дейтаграмма на точку доступа 0/dg создателя сообщения.

   MF_TCH (TeCHnical message)

      Признак того, что сообщение не написано пользователем, а создано
      программным обеспечением узла и является техническим. Технические
      сообщения НЕ ДОЛЖНЫ отображаться пользователю как обычные
      сообщения (в большинстве случаев они вообще не должны отображаться
      пользователю). Пользователь НЕ ДОЛЖЕН иметь прямого контроля над
      установкой этого флага. Технические сообщения предназначены для
      обмена интерфейсами взаимодействия с пользователем узлов между
      собой сопроводительной информацией, например, квитанциями
      (MF_RRC), статусными собщениями (для режима away и т.п.), или
      какой-либо другой информацией, определяемой атрибутами.

   MF_LocalReserved

      Поле зарезервировано для внутреннего использования программным
      обеспечением узла в своих целях и должно полностью игнорироваться
      при получении. Гарантируется, что поле не будет использовано в
      следующих версиях протокола для нужд самого протокола. Узлы могут
      использовать свои внутренние флаги в этом поле (например, признак
      прочтения сообщения пользователем).

3.5. Дейтаграммы.

   Одной из особенностей протокола TheSender является его расширяемость.
   Протокол может быть использован не только для передачи сообщений
   (основное назначение), но и для почти любого теоретически возможного
   взаимодействия между узлами. Реализуется это путем введения
   возможности обмена произвольными данными между узлами.

   По аналогии с протоколом UDP стека протоколов TCP/IP, вводится
   возможность передачи произвольных данных - дейтаграмм. Дейтаграмма
   (datagram) представляет собой пакет данных, рассматриваемый как
   единое целое в рамках протокола, передаваемый на удаленный узел
   за один прием, независимо от других подобных пакетов. В отличие
   от UDP, дейтаграммы TheSender надёжны, поскольку передаются поверх
   несущих соединений TCP, и могут теряться только в ограниченном
   числе случаев (как правило, с уведомлением об ошибке при этом).

3.5.1. Общие понятия.

   Под приложением в данном разделе понимается некая программная
   единица, работающая на узле, таковых может быть несколько. Физически
   приложение может быть частью программы, реализующей протокол
   TheSender на узле, но ничто не мешает приложению быть отдельной
   программой, каким либо образом взаимодействующей с основной
   программой TheSender узла.

   С целью обеспечения возможности одновременного взаимодействия
   нескольких приложений на узлах вводится понятие точки доступа
   (access point) узла, которое представляет собой аналог порта TCP или
   UDP (фактически, это понятие не называется портом с целью избежания
   терминологической путаницы). Было бы явно избыточным делать
   пространство точек размером в 2^16 единиц, как пространство портов
   TCP, поскольку даже последнее используется на текущий момент не
   полностью всеми приложениями мира. Сокращение этого пространства до
   256 точек при полном сохранении модели портов TCP, поэтому, выглядит
   довольно разумным, и предполагается, что это пространство не
   потребуется расширять (это потребует усложнения модели). Однако, с
   целью упрощения динамического выделения номеров точек, необходимо
   придерживаться некоторых условностей.

   Хотя все номера точек фактически равноправны - приложению требуется
   "связаться" (bind) с точкой и "прослушивать" её (listen) как для
   приёма, так и для отправки дейтаграмм с неё, но нижняя половина
   (номера с 0 по 127) выделяется для входящих "соединений", а верхняя
   (номера со 128 по 255) - для исходящих. То есть, номера с 0 до 127
   являются определенными для всех (well-known), номера со 128 по 255
   являются частными и не будут использованы для стандартизируемых
   приложений. Пространство номеров исходящих точек отдано под
   случайное выделение эфемерных (ephemeral) точек. Для дальнейшего
   упрощения задачи выделения эфемерных номеров точек их рекомендуется
   выделять снизу, начиная со 128, тогда как приложениям запрашивать
   их на прослушивание сверху, начиная с 255.
   
   Номер 0 предназначен для использования самим программным обеспечением
   узла TheSender (фактически, расширение здесь является необходимой
   частью протокола). В настоящее время определены два стандартных
   расширения протокола (их ДОЛЖЕН поддерживать любой клиент) с номерами
   1 (чат) и 2 (передача файлов). Возможное использование точки 0
   определено в других разделах документа (служебные дейтаграммы).
   Протоколы (их можно называть "субпротоколы") точек доступа 1 и 2
   определены в Приложении B "Чат и передача файлов".

   Стандартная запись точек доступа узла состоит в приписывании к нему
   через точку (point) десятичного номера точки (например,
   0058-3а26.43), с возможным приписыванием через слэш аббревиатуры dg
   ("дейтаграммы"), например, 0058-3а26.43/dg, поскольку в будущем
   могут быть введены потоки ("/st"), моделирующие соединения TCP.

3.5.2. Дейтаграммы.

   Дейтаграмма представляет собой пакет данных, пересылаемых без
   установления соединения и без подтверждения о доставке. Дейтаграмма
   может быть широковещательной, то есть послана на групповой адрес.
   Обычно дейтаграммы передаются внутри несущего соединения, поэтому
   их доставка надежна, однако в других случаях для передачи дейтаграмм
   может использоваться UDP или прохождение через промежуточные узлы
   (сервера), в каковых случаях она, естественно, ненадежна.
   Ненадежность здесь возникает из-за потенциальной возможности потери
   соединения с получателем уже после того, как дейтаграмма была
   принята промежуточным узлом. Хотя вероятность подобного события
   мала, и промежуточный узел ДОЛЖЕН попытаться известить отправителя
   об ошибке (что не даёт информации, однако, сколько дейтаграмм было
   потеряно), приложению следует считать, что доставка дейтаграмм
   является ненадежной в любом случае, когда не используется надежное
   (несущее) соединение с получателем. Это значит, что не гарантируется
   и доставка широковещательной дейтаграммы каждому получателю
   (поскольку в этом случае доставкой всегда занимается другой узел).
   Ненадежность эта, однако, обычно касается лишь нескольких последних
   дейтаграмм - поскольку используется TCP, возможные сценарии потери
   дейтаграмм весьма ограничены, сравнительно с UDP. Следует иметь
   в виду, что при использовании непрямых соединений и большой скорости
   передачи дейтаграмм потенциально возможен и приход дейтаграмм
   на узел назначения в другом порядке (reordered). Впрочем, для
   большинства приложений все эти маловероятные события, скорее всего,
   окажутся несущественными.

   Дейтаграмма всегда инкапсулируется во фрейм в единичном экземпляре,
   однако с целью позволить передачу сообщений об ошибках, обеспечить
   выравнивание размера заголовка и возможные расширения в будущем,
   длина дейтаграммы, а также адреса узлов отправителя и получателя,
   прописаны в её заголовке в явном виде.

3.5.3. Формат заголовка дейтаграммы:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |                           FromNodeID                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |                            ToNodeID                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8
   |    SrcPoint   |    DstPoint   |      Length / ErrorCode       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 12

   Описание полей:

   FromNodeID

      Адрес узла-отправителя дейтаграммы. Не может быть групповым.

   ToNodeID

      Адрес узла назначения дейтаграммы. Может быть групповым.

   SrcPoint

      Исходящая точка дейтаграммы (на узле-отправителе).

   DstPoint

      Входящая точка дейтаграммы (на узле-получателе).

3.5.3.1. Поле длины / кода ошибки.

   Поля адреса отправителя и получателя (а также номера входящей и
   исходящей точки) дейтаграммы всегда реальные, соответствуют
   направлению её передачи. В поле длины записывается длина дейтаграммы,
   включая её заголовок. Однако поле длины может обозначать не только
   длину поля данных дейтаграммы - это определяется диапазоном его
   значений.

   В случае, если значение длины составляет 12 или меньше (а она не
   может быть меньше 13, поскольку дейтаграммы без данных запрещены),
   это означает дейтаграмму-код ошибки, в которой поле длины содержит
   код ошибки, а сама дейтаграмма состоит только из заголовка, длина
   которого равняется 12 байтам. Во всех остальных случаях это обычная
   дейтаграмма, максимально возможная её длина определяется максимально
   возможной длиной фрейма.

   Возможные коды ошибок:

   0 - административное запрещение передачи
   1 - точка доступа не используется приложением
   2 - узел назначения недоступен
   3 - подавление источника (source quench)

   Сообщение об ошибке никогда не генерируется в ответ на
   широковещательную дейтаграмму, а также в ответ на другое сообщение
   об ошибке, чтобы избежать бесконечного переброса сообщениями об
   ошибках. В таких случаях дейтаграмма, вызывающая ошибку, просто
   игнорируется (отбрасывается), что происходит также и в случаях, когда
   об ошибке невозможно адекватно сообщить с использованием имеющихся
   кодов сообщения об ошибках (например, внутренняя ошибка на
   промежуточном узле). Вообще говоря, дейтаграмма, вызвавшая ошибку,
   отбрасывается всегда, просто в одних случаях это вызывает отправку
   сообщения об ошибке, в других нет.

   Значение 0 возвращается промежуточным узлом, если действующая на
   нём политика безопасности не позволяет передать дейтаграмму дальше
   (например, администратор может установить такое запрещение для узла,
   бомбардирующего сеть широковещательными сообщениями с большой
   скоростью). Это же значение ошибки используется, если заголовок
   дейтаграммы был корректен, однако поле адреса узла-отправителя
   содержало подделанное значение. Дейтаграммы с некорректным
   заголовком, который невозможно восстановить, молча отбрасываются.

   Значение 1 означает недоступность точки доступа (она не связана ни с
   одним приложением). Может посылаться в обоих направлениях между
   узлами (см. 3.5.4). 

   Значение 2 означает невозможность доставки дейтаграммы на узел
   назначения. Один из промежуточных узлов может вернуть такое сообщение
   об ошибке, если дейтаграмма не может быть отправлена адресату,
   например, по причине его выключения или другой потери связи.

   Значение 3 обозначает слишком высокую скорость передачи дейтаграмм
   (получающее приложение не успевает их принимать) и является командой
   понизить скорость передачи. Рекомендуется при получении такого
   сообщения об ошибке понижать скорость передачи в 2 раза. Следует
   отметить, что это не ошибка в полной мере, исходная дейтаграмма была
   доставлена - на момент генерации сообщения узел пока еще был в
   состоянии принимать их.

   Значения 4-7 зарезервированы. Значения с 8 по 12 зарезервированы
   для приватного использования реализациями - гарантируется, что они
   не будут использованы в следующих версиях протокола.

3.5.4. Управление доставкой - рекомендации для приложений.

   Типичное использование дейтаграмм происходит по типу "запрос-ответ",
   поэтому первоначальную дейтаграмму будем обозначать также как
   "запрос", а посланную в обратном направлении как "ответ".
   Совокупность дейтаграмм из запроса и ответа можно назвать
   "транзакцией" (так что это неприменимо, скажем, к широковещательным
   дейтаграммам и к дейтаграммам, когда запросов и ответов несколько).

   Так как соединение не устанавливается, при ожидании ответа на
   дейтаграмму возникает проблема ожидания ответной дейтаграммы: как
   долго исходящая точка будет занята именно тем приложением, которое
   послало запрос? Не придет ли ответ слишком поздно, когда исходящую
   точку будет использовать уже другое приложение? Проблема решается,
   во-первых, разграничением направлений - игнорируются (с сообщением
   о неиспользуемой точке) дейтаграммы-ответы, пришедшие с тех адресов
   и точек, на которые не были посланы запросы (возможно, они были
   посланы предыдущим приложением, использовавшим эту точку доступа -
   в любом случае, получать ответ более некому), и, во-вторых,
   установкой таймаутов. Ответ на дейтаграмму следует ожидать не более
   15 минут, по истечению этого интервала приложение, никак более не
   использовавшее исходящую точку, должно её освободить. Интервал,
   впрочем, применяется именно к "транзакции", то есть, даже если точка
   используется дальше (по другим направлениям, скажем) и пришел с
   опозданием, большим данного интервала, ответ, его всё равно следует
   быть отброшен (можно сказать, что этот интервал - максимальное время
   существования записи о "транзакции" в некоей внутренней "таблице
   соединений" приложения).

3.5.5. Служебные дейтаграммы.

   Дейтаграммы, отправляемые на точку 0, используются для нужд самого
   протокола. Общий формат поля данных служебной дейтаграммы:

      1 байт                  произвольная длина
         ^                              ^
     ___/ \___   ______________________/ \________________________
    /         \ /                                                 \
   +-----------+----------------.........................----------+
   |   Family  |                      Data                         |
   +-----------+----------------.........................----------+

   Поле Family означает семейство типов дейтаграмм. Значение 0xff
   не предназназначено для приватного использования реализациями. Все
   остальные значения, кроме перечисленных ниже, зарезервированы для
   будущего использования.

3.5.5.1. Подтверждение о доставке.

   Отсылается по приёму узлом сообщения с установленным флагом MF_RRQ.
   Имеет формат:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |Family = 0x01 |          Константная строка 'RRC'              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |                                                               |
   |        MsgID сообщения, доставка которого подтверждена        |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 12

3.5.5.2. Снятие объявления.

   Отсылается автором объявления, сервером или оператором группы для
   досрочного снятия объявления (до истечения его срока жизни).
   Имеет формат:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |Family = 0x02 |          Константная строка 'BLT'              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |                                                               |
   |         MsgID объявления, снятие которого производится        |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 12

3.6. Атрибуты.

   В заголовках сообщений и в структуре NodeInfo (далее в разделе
   "заголовках") как для хранения требуемых данных, так и для могущих
   присутствовать в зависимости от ситуации, используются так
   называемые атрибуты. Они могут быть использованы для гибкого
   расширения формата заголовков. Атрибуты идут после фиксированной
   части заголовков (см. разделы 3.2 и 3.3), длина переменной части
   заголовка, состоящей из атрибутов, указана в его фиксированной
   части (точнее, высчитывается исходя из них).

3.6.1. Формат атрибута.

   Атрибуты имеют формат, обычно описываемый в литературе как TLV
   (Type-Length-Value):

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |            AttrType           |            AttrLen            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |                                                               |
   /                                                               /
   \                 AttrValue (variable length)                   \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   В поле AttrType указывается тип атрибута, в поле AttrLen - длина в
   байтах последующего поля AttrValue. Атрибуты в заголовках следуют
   друг за другом непрерывно, без промежутков, за полем AttrValue
   одного сразу AttrType следующего. Порядок следования атрибутов
   в заголовке может быть любой. Длина атрибута ограничивается только
   размером выделенного под атрибуты места в соответствующей структуре.
   Любые текстовые данные в атрибутах записываются в кодировке,
   указываемой полем CodePage соответствующей структуры.

   Специальный тип 0 (AT_NULL) обозначает пустое поле, оно может
   использоваться для заполнения "дыр" в заголовках. Длина такого поля
   учитывается как обычно, по полю AttrLen, содержимое поля AttrValue
   не имеет значения. Длина атрибута с типом AT_NULL может быть
   нулевой (это сделано для того, чтобы неиспользуемое место в
   заголовке могло быть просто инициализировано нулями), длина же
   атрибутов всех остальных типов нулевой быть не может. Кроме того,
   атрибут каждого типа ДОЛЖЕН встречаться в заголовке не более
   одного раза - повторения атрибутов с одинаковым типом разрешены
   только для AT_NULL, в виду возможности его использования для
   замещения вырезанных частей других атрибутов в заголовке
   (если реализатор посчитает нецелесообразным переформирование
   заголовка заново после удаления нескольких байт в его середине).

   Типы с номерами от 32768 до 49151 предназначены для свободного
   использования реализаторами в своих целях (рекомендуется, однако
   проверять версию программного обеспечения, поскольку использование
   этих номеров разными производителями может быть несовместимым
   друг с другом).

   Типы с номерами от 49152 до 65535 предназначены для внутреннего
   использования программным обеспечением узла (приватные номера),
   и должны игнорироваться при получении. РЕКОМЕНДУЕТСЯ, однако,
   вырезать их при передаче с целью уменьшения объёма передаваемых
   по сети данных.

   Все остальные номера, от 1 до 32767, считаются официально
   зарезервированными, кроме приведенного ниже списка всех
   используемых в настоящий момент типов атрибутов. Пространство
   номеров типов атрибутов едино для структур NodeInfo и заголовка
   сообщения. Если в структуре встречается атрибут с типом, не имеющим
   в ней смысла, он должен игнорироваться.

3.6.2. Атрибуты имен.

   Ниже приведены имена и значения атрибутов текстовой информации
   о пользователях.

   Тип атрибута        Описание атрибута

   AT_USERNAME, 1      Имя отправителя сообщения
   AT_MACHINE,  2      Имя компьютера отправителя
   AT_NICKNAME, 3      Nickname отправителя (альтернатива 1 и 2)
   AT_RECEIVER, 4      Получатель сообщения

   Все эти атрибуты представляют собой информацию о пользователе и
   являются текстовыми строками с длиной не более 40 байт. Допустимые
   символы - набор 33-126 ASCII и любые символы с номерами выше 127
   (определяется кодовой страницей). Регистр латинских букв не
   различается, регистр национальных алфавитов же важен (невозможно
   предусмотреть [простую] проверку идентичности двух атрибутов с
   учетом регистра для любой кодовой страницы).

   Содержимое атрибутов может быть любым, в том числе два одинаковых
   атрибута (одинаковых типов) могут принадлежать разным узлам. Это
   не имеет значения, поскольку узел уникально идентифицируется своим
   NodeID. Таким образом, коллизии nickname'ов, имевшие место в IRC,
   не имеют значения.

   Атрибуты AT_USERNAME и AT_MACHINE определяют имя пользователя и имя
   машины узла, а в сообщении - таковые параметры отправителя. Эта
   схема может иметь значение, например, в сетях Windows, где каждая
   машина обычно имеет своё NetBIOS-имя (в других системах это может
   быть, к примеру, hostname). Альтернативой является использование
   атрибута AT_NICKNAME для задания "псевдонима" пользователя.
   В случае, если заданы все три типа, отображение оставляется на
   усмотрение реализатора. Структура информации об узле ДОЛЖНА
   содержать хотя бы один из трех атрибутов (в случае же, если это
   группа, им может быть только AT_NICKNAME, а AT_USERNAME и
   AT_MACHINE запрещены).
   
   Атрибут AT_RECEIVER имеет смысл только в сообщении, не в NodeInfo,
   и обычно содержит одно из значений AT_USERNAME, AT_MACHINE или
   AT_NICKNAME для узла получателя.
   
   В сообщении все атрибуты имен могут полностью отсутствовать - эта
   информация будет взята получателем из структуры NodeInfo отправителя.
   Однако, в случае, если какой-либо из них присутствовал в сообщении,
   ответ на это сообщение ДОЛЖЕН содержать атрибут AT_RECEIVER со
   значением, равным значению одного из полей оригинала. Это позволяет
   реализовать (если реализатор пожелает), например, схему использования
   нескольких AT_USERNAME при одинаковом AT_MACHINE - своего рода
   коллективный доступ нескольких пользователей к одной запущенной
   копии TheSender на машине (а-ля BBS в 80-х / 90-х годах).

3.6.3. Атрибуты списков узлов.

   Ниже приведены имена и значения атрибутов, являющихся списками
   NodeID.

   Тип атрибута        Описание атрибута

   AT_NODELIST, 5      Общий список узлов
   AT_OPERLIST, 6      Список операторов группы

   Данные атрибуты являются списками NodeID и представляют собой
   массив NodeID (имеют размер, кратный 4 байтам). Атрибут AT_NODELIST
   имеет разное значение в зависимости от того, в какой структуре он
   находится (но не может содержать специальные NodeID в любом случае).
   В сообщении он используется как указание дополнительных получателей
   сообщения, как групповых, так и нет (аналог Carbon Copy в e-mail
   и заголовка Newsgroups в NNTP), и может иметь размер до 63 NodeID
   (порядок следования которых неважен). В структуре информации о
   групповом NodeID это перечень всех членов группы (групповые NodeID
   недопустимы) и может иметь размер до 16350 NodeID (что ограничивает
   максимальное количество узлов в группе). В структуре NodeInfo
   обыкновенного узла атрибут AT_NODELIST может иметь до 63 элементов
   и представляет собой перечень групп, в которые входит узел (т.е.
   разрешены только групповые NodeID), причем первый элемент массива
   указывает группу по умолчанию данного узла, порядок следования
   остальных элементов неважен.

   Атрибут AT_OPERLIST предназначен в основном для структур информации
   о группе (и ДОЛЖЕН присутствовать в ней), максимальный его размер
   составляет 63 элемента. Он перечисляет операторов группы, то есть
   узлы (групповые NodeID недопустимы), которым разрешено модифицировать
   приватную информацию о группе, управлять объявлениями и т.п. (все
   операции, кроме изменения структуры NodeInfo группы). Кроме того,
   первый элемент означает "владельца" группы, то есть узел, которому
   разрешено изменять структуру NodeInfo группы (в том числе менять
   владельца). Порядок остальных элементов неважен. Еще одно назначение
   этого атрибута - управление разрешением доставки сообщений с
   приоритетом 3 (критических). Сервер ДОЛЖЕН запрещать отправку таких
   сообщений узлам не из этого списка (кроме, возможно, некоторых
   узлов, которым это разрешено административными политиками сервера).
   Это назначение атрибута AT_OPERLIST является единственным имеющим
   смысл, когда он присутствует в структуре NodeInfo обычного узла,
   определяя узлы, могущие отправить приватное сообщение с приоритетом
   3 (следует отметить, впрочем, что при прямых соединениях этим должен
   заниматься сам узел); при отсутствии этого атрибута узлу могут быть
   доставлены только лишь групповые сообщения с приоритетом 3, как
   описано выше.

3.6.4. Атрибуты возможностей узла.

   Поскольку существуют разные форматы текста и кодовые страницы
   (см. соотвествующие Приложения), то разные узлы могут поддерживать
   разные подмножества форматов и кодовых страниц, что фиксируется
   в приведенных ниже атрибутах.

   Тип атрибута        Описание атрибута

   AT_CAPFMT, 7        Поддерживаемые форматы
   AT_CAPLNG, 8        Поддерживаемые кодовые страницы

   Атрибут AT_CAPFMT представляет собой массив байт, каждый байт
   трактуется как число - номер поддерживаемого формата (таким образом,
   максимальная длина составляет 64 байта). Порядок следования неважен.
   При отправке группового сообщения узел-отправитель ДОЛЖЕН отправить
   сообщение с таким форматом, которое поддерживается всеми узлами,
   входящими в группу, кроме серверов, за одним исключением. Поскольку
   формат 0 всегда поддерживается, в атрибуте AT_CAPFMT он имеет
   специальное значение: его наличием узел указывает, что для
   процедуры определения поддерживаемого всеми формата данный узел
   может быть проигнорирован (считается, что он поддерживает все
   возможные форматы). Следует отметить, что такое исключение
   допускается только для групповых сообщений, для всех других целей
   использования форматов исключений нет. В случае отсутствия атрибута
   AT_CAPFMT считается, что узел поддерживает только формат 0.

   Атрибут AT_CAPLNG представляет собой массив двухбайтовых беззнаковых
   целых чисел, перечисляющий поддерживаемый узлом кодовые страницы. Он
   ДОЛЖЕН быть отсортирован в порядке возрастания. При отправке
   групповых сообщений узлу-отправителю СЛЕДУЕТ отправлять сообщение
   в кодировке, поддерживаемой всеми узлами группы. При отсутствии
   атрибута AT_CAPLNG считается, что узел поддерживает любую кодовую
   страницу.

3.6.5. Опциональные атрибуты информации об узле.
   
   Структура NodeInfo узла МОЖЕТ содержать дополнительные атрибуты с
   информацией об узле, имеющие значение только для человека и/или
   программного обеспечения узлов (на работу протокола они не влияют).
   Они представляют собой текстовые строки длиной до 255 символов.

   Тип атрибута        Описание атрибута

   AT_FULLNAME, 9      Полное имя пользователя
   AT_VERSION, 10      Версия программного обеспечения узла
   AT_DESCRIPTION, 11  Произвольное текстуальное описание узла

   Атрибут AT_FULLNAME может содержать полное имя пользователя
   (рекомендуется формат имен переписки e-mail, типа "John S. Doe").
   Атрибут AT_VERSION содержит версию программного обеспечения узла
   (и, возможно, операционной системы). Атрибут AT_DESCRIPTION
   представляет собой описание узла, предоставленное его пользователем.
   Формируется человеком и для человека, на работу протокола никакого
   влияния оказывать не может (в отличие от версии, которая потенциально
   может быть использована программным обеспечением).

3.6.6. Дополнительные атрибуты сообщений.

   В сообщении могут присутствовать атрибуты, изменяющие нормальную
   последовательность обработки сообщения или смысл отдельных полей.

   Тип атрибута        Описание атрибута

   AT_MULTIPART, 13    Фрагмент большого сообщения, разбитого на части
   AT_EXPIRE, 14       Срок времени жизни сообщения
   AT_FILEINFO, 15     Информация о файле, вложенном в сообщение

   Атрибут AT_MULTIPART предназначен для использования во фрагментах
   сообщения с размером более 64 Кб, разбитого на части. Его формат
   не определён, атрибут зарезервирован для последующих версий.

   Атрибут AT_EXPIRE задаёт срок времени жизни сообщения. Он всегда
   имеет длину 2 октета и представляет собой беззнаковое целое число,
   задающее срок жизни сообщения в минутах с момента, отмеченного в
   поле Msg.Time (значение 0 или отсутствие атрибута задаёт
   использование настроек по умолчанию). По истечению этого срока
   сообщение СЛЕДУЕТ удалить. В случае установленного флага MF_BLT
   (то есть, если сообщение является объявлением) значение атрибута
   трактуется несколько иначе - это срок, после которого объявление
   ТРЕБУЕТСЯ "снять" (программное обеспечение узлов МОЖЕТ не удалять
   объявление после "снятия"). Кроме того, для объявления временем
   жизни по умолчанию всегда являются 1 сутки.

   Атрибут AT_FILEINFO содержит информацию о файле, вложенном в
   сообщение. Если этот атрибут присутствует, то поле Msg.AddonData
   представляет собой содержимое такого файла (его размер определяется
   доступным местом для поля AddonData в сообщении). Формат атрибута:

      4 байта                  от 1 до 255 байт
     ___/^\___   ______________________/^\________________________
    /         \ /                                                 \
   +-----------+----------------.........................----------+
   |LastModTime|                    FileName                       |
   +-----------+----------------.........................----------+

   Здесь LastModTime есть время последнего изменения файла. По сети
   передаётся только оно, так как другие времена файла, предоставляемые
   некоторыми ОС, такие, как время последнего доступа, создания,
   изменения информации о файле, передавать нет смысла, поскольку они
   будут установлены получателем в текущее время. Поле FileName
   содержит имя передаваемого файла, допустимы любые разрешенные POSIX
   символы.

3.7. Дополнительные структуры узла.

   С каждым узлом, помимо общей структуры информации о нём, связываются
   еще две структуры - Presence, описывающей параметры текущего
   подключения узла к сети, и PrivInfo, в которой содержится приватная
   информация об узле (или группе), в противовес публично доступной
   структуре NodeInfo.

3.7.1. Структура Presence.

   Структура Presence содержит состояние подключения клиента в данный
   момент времени. Она применяется в ответах на запросы о статусе
   клиента, а также в оповещениях об изменении статуса узла.

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |                            NodeID                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |      RESERVED     |C|S|T|State|              Port             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8
   |                            IntAddr                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 12
   |                            ExtAddr                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 16 

   NodeID

      NodeID узла, который описывает эта структура Presence.

   C (Changed)

      Флаг указывает на то, что обновилась структура NodeInfo узла,
      и её следует получить целиком заново. Применяется только в
      рассылках оповещений об изменении статуса узла.

   S (Serverless)

      Флаг указывает на то, что узел работает в бессерверном режиме.
      Несовместим с флагом T (а также не может быть у узла, являющегося
      сервером). Бессерверный режим не является нормальным, это
      вынужденный режим для клиента при отсутствии сервера и подробно
      рассматривается в соответствующих разделах.

   T (Through server)

      Этот флаг указывает на то, что адреса и порты не используются,
      так как узел недоступен для входящих соединений (например,
      находится за NAT/Firewall), постоянно поддерживает соединение
      с сервером, и все посылки сообщений и дейтаграмм узлу должны
      выполняться через сервер. Возможные исключения описаны ниже.
      Сервер МОЖЕТ выполнить попытку соединения на указанный клиентом
      адрес и порт с целью проверки валидности этой информации, и
      выставить клиенту флаг T, если он еще не был установлен.

   State

      Online-статус узла. Значения:

      0 - Offline: нет в сети (выключен)
      1 - Normal: в сети, обычное состояние
      2 - Away: отошел ненадолго
      3 - N/A (not available): недоступен (давно нет у компьютера)
      4 - Busy/Occupied: занят
      5 - DND (do not disturb): не беспокоить
      6 - Free for chat: свободен, готов чатиться
      7 - Invisible: невидимый

      Все online-значения, кроме invisible, не влияют на работу
      протокола и относятся к взаимодействию с пользователем. Следует
      отметить, что в состоянии 0 (offline) значения остальных полей
      структуры (например, адресов) не определены.

   IntAddr, ExtAddr, Port и использование флага T

      IP-адрес и порт, к которым необходимо осуществлять подключение для
      соединения с данным клиентом. Если в соответствующем поле нули
      (т.е. адрес 0.0.0.0), то поле ДОЛЖНО игнорироваться. Поле ExtAddr
      так же ДОЛЖНО игнорироваться при установленном флаге T. Сервер
      МОЖЕТ заменить недостоверное поле ExtAddr на имеющуюся у него
      информацию об адресе другого конца TCP-соединения.
      
      Клиент при соединении заполняет поля адресов: в поле IntAddr
      помещается собственный IP-адрес, в поле ExtAddr может быть
      помещен внешний адрес узла, если клиент заранее его знает
      (например, пользуется SOCKS-прокси) либо же установить флаг T,
      если клиент не знает своего внешнего адреса, но известно, что
      он отличается от внутреннего. Во всех остальных случаях клиенту
      неизвестно, достижим ли он извне, поэтому это должно определяться
      сервером.

      Назначение поля IntAddr - более эффективное использование сети
      клиентами, находящимися в одной "серой" подсети. Клиент МОЖЕТ
      соединиться с другим клиентом, у которого IntAddr находится в
      одной с ним подсети (или существует маршрут в эту сеть, отличный
      от маршрута по умолчанию), как при установленном флаге T, так
      и без него.

      Поле Port задаёт TCP-порт, к которому необходимо выполнять
      подключение для установления соединения с клиентом. Если клиент
      знает свой внешний адрес, то поле Port используется совместно с
      внешним адресом, а при попытке соединения с IntAddr (см. выше)
      используется значение по умолчанию 9426. Если оно в
      дейтсвительности не 9426 (например, узел не смог получить этот
      порт ввиду его занятости другим узлом, работающим на том же
      хосте), то соединение с ним на IntAddr, очевидно, не может быть
      установлено. Поэтому узлы, выполняющие попытки соединения на
      IntAddr, при неудаче (например, ответил другой NodeID) должны
      выполнить попытку соединения с ExtAddr:Port, если флаг T не
      установлен. Возможно также указание использования Port вместе
      с IntAddr, если ExtAddr установлен в недостоверное (нулевое)
      значение.

      В любых случаях [нескольких, в порядке перебора адресов] неудачных
      попыток соединения (а также нулевых полей), даже если флаг T
      не установлен, дальнейшие попытки коммуникации следует вести
      через сервер, как если бы T был установлен.

3.7.2. Структура PrivInfo.

   Структура PrivInfo содержит приватную информацию об узле или группе.
   Сервер ДОЛЖЕН давать возможность получить содержимое структуры об
   узле только другому серверу, самому узлу или членам группы (если
   это группа). Формат структуры:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |                            NodeID                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   | InvisibleLen  |  VisibleLen   |  DenyMsgsLen  | AllowMsgsLen  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8
   |                                                               |
   /                                                               /
   \                InvisibleList (variable length)                \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                                                               /
   \                  VisibleList (variable length)                \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                                                               /
   \                 DenyMsgsList (variable length)                \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                                                               /
   \                 AllowMsgsList (variable length)               \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   В поле NodeID содержится идентификатор узла или группы, к которому
   относится данная структура PrivInfo. Далее следуют четыре поля длин
   соответствующих списков. Длины указываются в единицах NodeID,
   поскольку списки представляют собой массивы NodeID. Длина может
   варьироваться от 0 (соответствующий список пуст) до 255 NodeID
   (1020 байт).

   Каждый список может содержать как обычные, так и групповые NodeID,
   в произвольном порядке. Узел считается входящим в список, если он
   явно указан в нём или входит в любую из перечисленных в нём групп.
   Запрещено помещать в список любые специальные NodeID (они не имеют
   смысла, кроме спецгруппы глобальных сообщений всей сети (ffff-ffff),
   но последнее можно решить другими методами).

   Список InvisibleList содержит перечень узлов, для которых данный
   узел всегда находится в статусе Offline (всегда невидим). Для
   группы это перечень узлов, которым запрещено присоединяться к
   группе (banned nodes), которым, к тому же, запрещено отправлять
   группе сообщения и дейтаграммы (если у неё не установлен флаг
   NF_NOEXTMSG).

   Список VisibleList содержит перечень узлов, которые могут видеть
   статус Invisible данного узла. Список VisibleList имеет приоритет
   над списком InvisibleList (если какой-то узел попадает в оба). Для
   группы список VisibleList означает список исключений из списка
   InvisibleList (а для приватной группы, кроме того, список узлов,
   которым разрешено получать информацию о группе).

   Списки VisibleList и InvisbleList, помимо вышеперечисленного,
   управляют также возможностью запроса сообщений группы с сервера по
   MsgID для публичных групп (со сброшенным флагом NF_PRIVATE),
   ожидаемым образом - если узлу запрещено присодиняться к группе,
   то ему запрещено и запрашивать сообщения из неё.

   Список DenyMsgsList содержит перечень узлов, которым запрещено
   отправлять сообщения и дейтаграммы этому узлу или группе (через
   сервер; при попытке прямого соединения узел должен обрабатывать это
   самостоятельно). Для группы он не требует пересечения со списком
   InvisibleList - узел может состоять в группе, принимать отправляемые
   на неё сообщения, но быть не в состоянии отправлять ей сообщения
   ("devoice"); также он позволяет лишать некоторые узлы вне группы
   права доставки ей сообщений без установки флага NF_NOEXTMSG.
   
   Список AllowMsgsList представляет собой список исключений из списка
   AllowMsgsList (имеет над ним приоритет).


4. СПРАВОЧНИК ПО КОМАНДАМ.

   В этом разделе описываются непосредственно команды протокола и их
   формат. Они делятся на два вида: команды, требующие обязательного
   ответа удаленной стороны, и команды, ответ на которые запрещен.
   Здесь под ответом понимается отправка фрейма с установленным флагом
   FLG_REPLY. Команды, требующие ответа, имеют коды, меньшие 0x80 (т.е.
   пространство номеров разделено на две половины). Ниже приведены
   сводная таблица всех команд и ответов на них, с указанием значений
   констант (константы команд начинаются на CM_, а ответов на RE_),
   в алфавитном порядке. Все значения кодов, не приведенные в списке,
   зарезервированы для будущих версий протокола.

   Константа           Значение

   CM_ALIVE            0x80
   CM_AUTH             0x0a
   CM_DATAGRAM         0x88
   CM_ERROR            0x82
   CM_GETMSG           0x01
   CM_GETNINFO_IMS     0x02
   CM_GETNODEINFO      0x03
   CM_GETPRESENCE      0x05
   CM_GETPRIVINFO      0x04
   CM_JOIN             0x85
   CM_KICK             0x86
   CM_LEAVE            0x87
   CM_LISTGROUPS       0x06
   CM_LISTMSGS         0x07
   CM_POSTMSG          0x08
   CM_PRESENCE         0x83
   CM_QUIT             0x81
   CM_SENDMSG          0x84
   CM_SETNODEINFO      0x0b
   CM_SETPRIVINFO      0x0c
   CM_REGISTER         0x0d
   CM_TIME             0x09

   RE_OK               0x00
   RE_AUTH             0x01
   RE_EBUSY            0x04
   RE_EINVAL           0x03
   RE_ENOTFOUND        0x07
   RE_EOPNOTSUPP       0x05
   RE_EPERM            0x02
   RE_EUNKNOWN         0x06
   RE_LISTGROUPS       0x0a
   RE_LISTMSGS         0x0b
   RE_MESSAGE          0x0c
   RE_NINFO_NOTMS      0x0d
   RE_NODEINFO         0x0e
   RE_PRESENCE         0x08
   RE_PRIVINFO         0x0f
   RE_REGFAILED        0x10
   RE_TIME             0x09

   Ниже приведена сводная таблица возможных кодов ответа на команды
   (пометка 'x' стоит только в том случае, если на команду данного
   столбца возможен код ответа соответствующей строки).

                  |CM_|CM_|CM_|CM_|CM_|CM_|CM_|CM_|CM_|CM_|CM_|CM_|CM_
                  |AUT|GET|GET|GET|GET|GET|LIS|LIS|POS|SET|SET|REG|TIM
   Код ответа     |H  |MSG|NIN|NOD|PRE|PRI|TGR|TMS|TMS|NOD|PRI|IST|E
                  |   |   |FO_|EIN|SEN|VIN|OUP|GS |G  |EIN|VIN|ER |
                  |   |   |IMS|FO |CE |FO |S  |   |   |FO |FO |   |
   ---------------+---+---+---+---+---+---+---+---+---+---+---+---+---
   RE_OK          |   |   |   |   |   |   |   |   | x | x | x |   |
   RE_AUTH        | x |   |   |   |   |   |   |   |   |   |   |   |
   RE_EBUSY       |   | x | x | x | x | x |   | x | x | x | x | x |
   RE_EINVAL      |   | x | x | x | x | x |   | x | x | x | x | x |
   RE_ENOTFOUND   |   | x | x | x |   | x |   | x | x | x | x |   |
   RE_EOPNOTSUPP  |   |   |   |   |   |   |   |   |   |   |   |   |
   RE_EPERM       |   | x | x | x |   | x |   | x | x | x | x | x |
   RE_EUNKNOWN    |   | x | x | x | x | x |   | x | x | x | x | x |
   RE_LISTGROUPS  |   |   |   |   |   |   | x |   |   |   |   |   |
   RE_LISTMSGS    |   |   |   |   |   |   |   | x |   |   |   |   |
   RE_MESSAGE     |   | x |   |   |   |   |   |   |   |   |   |   |
   RE_NINFO_NOTMS |   |   | x |   |   |   |   |   |   |   |   |   |
   RE_NODEINFO    |   |   | x | x |   |   |   |   |   |   |   |   |
   RE_PRESENCE    |   |   |   |   | x |   |   |   |   |   |   |   |
   RE_PRIVINFO    |   |   |   |   |   | x |   |   |   |   |   |   |
   RE_REGFAILED   |   |   |   |   |   |   |   |   |   |   |   | x |
   RE_TIME        |   |   |   |   |   |   |   |   |   |   |   |   | x
                   
4.1. Общие статусные коды.

   Существуют коды ответа, которые не привязаны к конкретной команде и
   могут быть посланы в ответ на любую команду. Эти статусные коды
   перечислены ниже, все они, кроме RE_EINVAL, не имеют аргументов
   (длина передаваемых данных нулевая).
   
   Код RE_OK означает успешное выполнение команды.
   
   Код RE_EBUSY означает временную ошибку, запрос следует повторить
   позже.

   Код RE_EINVAL означает ошибку выполнения команды ввиду того, что
   данные в команде имели неправильный формат (неудовлетворяли
   спецификации протокола TheSender). Код RE_INVAL имеет аргументом
   двухбайтное целое число, означающее смещение в данных команды, по
   которому была найдена ошибка. Реализация МОЖЕТ не заботиться о
   передаче смещения, а просто индицировать ошибку, в этом случае
   смещение должно равняться нулю.

   Код RE_ENOTFOUND означает, что указанный в команде NodeID, MsgID
   или т.п. не был найден удаленной стороной.

   Код RE_EOPNOTSUPP означает, что была передана команда с неизвестным
   кодом, неподдерживаемая удаленной стороной. Команды же с неизвестным
   кодом из диапазона команд с запрещенным ответом просто отбрасываются.

   Код RE_EPERM ("Permission denied") означает, что команда не может
   быть выполнена по соображениям безопасности, например, при попытке
   запроса чужого приватного сообщения, и т.п.

   Код RE_EUNKNOWN означает, что во время выполнения команды на
   удаленной стороне возникла неустранимая внутренняя ошибка.

4.2. Манипуляции соединениями.

4.2.1. CM_ALIVE

   Команда CM_ALIVE используется в начале соединения, для идентификации
   сторон, в бессерверном режиме, а также при проверке живости
   соединения - если локальная сторона не получала никаких данных от
   удаленной стороны в течение 60 секунд, она генерирует команду
   CM_ALIVE. Удаленная сторона по получении команды CM_ALIVE должна
   сгенерировать в ответ свою команду CM_ALIVE (следует обратить
   внимание, что это надо делать не при любом получении CM_ALIVE, во
   избежании бесконечного переброса командами CM_ALIVE), и если
   локальная сторона в течение 60 секунд не получит ответа, соединение
   ДОЛЖНО быть закрыто.

   Поле данных команды CM_ALIVE имеет размер 4 байта и содержит
   NodeID узла, сгенерировавшего эту команду. При получении CM_ALIVE
   всегда следует проверять, что NodeID в ней соответствует NodeID
   удаленной стороны.

4.2.2. CM_AUTH

   Команда CM_AUTH используется для аутентификации сторон в соединениях.
   Необходимость её использования определяется реализациями - в случае
   использования это первая команда (после CM_ALIVE), которую посылает
   сторона, принявшая соединение. Другая сторона отвечает кодом RE_AUTH,
   и, если аутентификация была неуспешной, соединение закрывается (с
   уведомлением CM_ERROR), в противном случае считается, что другая
   сторона действительно та, за которую себя выдает, и соединение просто
   продолжается (с возможной встречной аутентификацией). Аутентификация
   МОЖЕТ быть повторена любое количество раз за сессию (с той разницей,
   что в этом случае узлам не требуется ждать завершения аутентификации
   для продолжения обмена данными). Формат поля данных запроса:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |                       SupportedMethods                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |                                                               |
   /                                                               /
   \                   Challenge (variable length)                 \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Формат поля данных ответа:

    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+..............................-+-+-+-+-+
   | R |M| Method  |         Response (variable length)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+..............................-+-+-+-+-+

   Здесь поле R означает зарезервированные биты, а M (Mutual) - флаг
   требования взаимной аутентификации.

   Проведение аутентификации возможно несколькими методами. На текущий
   момент определены такие:

   0 - пароль передается в открытом виде
   1 - CHAP-MD5
   2 - HMAC-MD5
   3 - HMAC-SHA-1
   4 - HMAC-SHA-256
   5 - Kerberos V5

   Остальные значения зарезервированы для будущего использования.

   Передачу пароля в открытом виде ДОЛЖНА поддерживать любая реализация,
   хотя СЛЕДУЕТ поддерживать хотя бы один из более защищенных методов.
   Сторона, посылающая CM_AUTH, устанавливает в поле SupportedMethods
   биты, соответствующие поддерживаемым методам, следующим образом:
   самый младший бит для метода 0, следующий за ним для метода 1, и так
   далее, то есть, например, при поддержке методов 0, 1 и 3 значение
   SuportedMethods как 32-битного беззнакового числа будет 2^3 + 2^1 +
   + 2^0 = 11. Далее устанавливается Challenge, это произвольная
   последовательность байтов (длина известна из длины фрейма).

   Аутентифицирующаяся сторона выбирает наилучший поддерживаемый метод,
   пишет его номер в поле Method, и устанавливает поле Response в
   соответствии с вычисленным значением для выбранного метода, например,
   для метода CHAP-MD5 [RFC 1994] это будет 16 байт значения дайджеста,
   для пароля в открытом виде он передаётся как есть, без завершающих
   нулей (длина известна из длины фрейма), для методов 2, 3 и 4 оно
   вычисляется с использованием соответствующей хэш-функции по
   алгоритму, описанному в [RFC 2104], [RFC 2202] и [RFC 4231].

   Если установлен флаг M, то аутентифицирующаяся сторона также желает
   подтверждения подлинности другой стороны, которая в таком случае
   ДОЛЖНА по приёму и успешной проверке RE_AUTH не посылать никаких
   команд, а ждать встречный CM_AUTH. В случае, если был использован
   метод 0, флаг M ДОЛЖЕН игнорироваться, а соединение МОЖЕТ быть
   закрыто, поскольку при передаче пароля открытым текстом взаимная
   аутентификация бессмысленна.

   Отдельно необходимо отметить использование Kerberos V5 [RFC 1510].
   В случае его использования поле Challenge не используется, а в
   Response помещается сообщение KRB_AP_REQ. В случае установленного
   флага M удаленная сторона ДОЛЖНА прогинорировать выставленные
   "для приличия" поля во встречном CM_AUTH и ответить сообщением
   KRB_AP_REP. Длина сообщений Kerberos НЕ ДОЛЖНА превышать 65520 байт.

4.2.3. CM_ERROR

   Команда CM_ERROR используется для уведомления об асинхронной ошибке.
   Формат её поля данных:

    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...................+-+-+-+
   |    Command    |    Response   | Description (variable length) |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...................+-+-+-+

   Поле Command обозначает код команды, вызвавшей ошибку, если это
   значение 0x80 или выше, один из кодов ответа RE_*, если это значение
   от 0x01 до 0x7f, или ошибку, не связанную с конкретной командой,
   если это 0x00. Поле Response содержит собственно код ошибки. Поле
   Description МОЖЕТ быть непустым, в каковом случае оно содержит
   текстовую строку (разрешены только ASCII-символы с кодами 32-126)
   с описанием ошибки, предназначенным для показа пользователю.

   Если поле Command имеет значение от 0x01 до 0x7f, то это обычно
   ответ на один из кодов ответа RE_* другой стороны, в котором
   была замечена ошибка формата (Response будет равен RE_EINVAL).

   Если значение поля Command составляет 0x80 или выше, то это ответ
   на одну из команд, ответ на которые обычными средствами запрещен,
   обычно, впрочем, это будет опять-таки EINVAL в Response (чаще всего
   в рещультате каких-либо сбоев удаленной стороны, в результате которых
   формат команд не удовлетворяет спецификации TheSender). Исключением
   являются команды CM_JOIN, CM_LEAVE и CM_KICK, для которых, помимо
   обычных кодов ошибок, определены коды 0xfe (клиент находится в
   слишком большом числе групп) и 0xff (превышено максимальное число
   групп в сети).

   Соединение в указанных выше случаях (кроме CM_JOIN, CM_LEAVE и
   CM_KICK) МОЖЕТ быть закрыто после посылки CM_ERROR.

   Если значение Command равняется 0x00, то это ошибка, не связанная
   с конкретной командой, а с самим соединением. В этом случае
   соединение ДОЛЖНО быть закрыто после отправки CM_ERROR. Определенные
   для этого случая значения Response:

   0x00 - недопустимая версия протокола или ошибка формата фрейма
   0x01 - ошибка аутентификации или другая ошибка безопасности
   0x02 - недопустимая команда [на данном этапе протокола]
   0x03 - узел исчерпал ресурсы, следует повторить соединение позже
   0x04 - flood: превышена максимально допустимая скорость отправки
   0x05 - соединение прервано вмешательством оператора узла
   0xff - другая ошибка, подробности в текстовом сообщении

4.2.4. CM_PRESENCE

   Команда CM_PRESENCE используется уведомления удаленной стороны об
   изменениях статуса, и передает структуру Presence. Типичное
   использование команды - клиент отправляет эту структуру серверу,
   а сервер рассылает её всем клиентам в группе. Ответ на команду
   запрещен. Поле данных имеет размер 16 байт и содержит структуру
   Presence.

4.2.5. CM_GETPRESENCE

   Команда используется для запроса текущего статуса узла или набора
   узлов. Поле данных команды представляет собой массив NodeID
   (групповые недопустимы) узлов, структуру Presence которых требуется
   получить. Максимальный размер массива - 4095 элементов.

   В ответ возвращается код RE_PRESENCE, с полем данных, являющимся
   массивом структур Presence для запрошенных узлов. В случае
   некорректного запроса, например, несуществующие NodeID или размер
   массива превышал 4095 элементов (таким образом, ответ не поместится
   во фрэйм), при наличии хотя бы одного корректного NodeID удаленная
   сторона ДОЛЖНА проигнорировать некорректные элементы и вернуть ответ
   только для корректных. Порядок элементов в массивах запроса и ответа
   неважен.

4.2.6. CM_QUIT

   Команда CM_QUIT не имеет данных, не требует ответа и служит
   уведомлением другой стороны о корректном завершении соединения - по
   её получению необходимо закрыть соединение. Сервер при получении
   этой команды изменяет статус клиента в структуре Presence на Offline
   и рассылает оповещение об этом всем группам, в которых состоял
   клиент. Клиент при получении CM_QUIT от сервера МОЖЕТ переключиться
   в бессерверный режим, в зависимости от своих настроек.

4.3. Узлы и группы.

4.3.1. CM_SETNODEINFO

   Команда используется для установки клиентом обновленной версии
   структуры NodeInfo. В поле данных содержится одна структура NodeInfo.
   Сервер может вернуть код ответа RE_OK в случае успешной операции
   либо один из общих статусных кодов (например, RE_EPERM, если клиент
   попытался изменить NodeInfo другого узла или не принадлежащей ему
   группы). Серверу СЛЕДУЕТ разослать структуру Presence для узла с
   установленным флагом C всем группам, членом которых он является.

4.3.2. CM_GETNODEINFO

   Команда предназначена для запроса с удаленной стороны структуры
   NodeInfo. Поле данных команды имеет размер 4 байта и являет собой
   NodeID узла (или группы), для которого запрашивается информация.
   Удаленная сторона может вернуть один из общих статусных кодов в
   случае ошибки или код RE_NODEINFO в случае успешного выполнения,
   поле данных которого будет содержать запрашиваемую структуру
   NodeInfo.

4.3.3. CM_GETNINFO_IMS

   Команда CM_GETNINFO_IMS (If-Modified-Since) предназначена для запроса
   структуры NodeInfo только в том случае, если она изменилась с
   указанного момента времени (который может быть определен, например,
   с помощью команды CM_TIME). Формат поля данных команды:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |                            NodeID                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |                             Time                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8

   Здесь к NodeID узла, информация о котором запрашивается, добавлено
   поле Time. В дополнение к обычным статусным кодам в случае ошибок
   (см. описание CM_GETNODEINFO), может быть возвращено значение
   RE_NINFO_NOTMS (без данных). Оно возвращается в случае, если значение
   поля LastUpdTime в соответствующей структуре NodeInfo меньше либо
   равно значению Time в запросе. В противном случае возвращается
   обычный код RE_NODEINFO.

4.3.4. CM_SETPRIVINFO

   Команда используется для установки клиентом обновленной версии
   структуры PrivInfo. В поле данных содержится одна структура NodeInfo.
   Сервер может вернуть код ответа RE_OK в случае успешной операции
   либо один из общих статусных кодов (например, RE_EPERM, если клиент
   попытался изменить PrivInfo другого узла или группы, оператором
   которой он не является).

4.3.5. CM_GETPRIVINFO

   Команда предназначена для запроса с удаленной стороны структуры
   PrivInfo. Поле данных команды имеет размер 4 байта и являет собой
   NodeID узла (или группы), для которого запрашивается информация.
   Удаленная сторона может вернуть один из общих статусных кодов в
   случае ошибки или код RE_PRIVINFO в случае успешного выполнения,
   поле данных которого будет содержать запрашиваемую структуру
   PrivInfo.

4.3.6. CM_LISTGROUPS

   Команда предназначена для запроса клиентом с сервера списка всех
   групп, имеющизся в сети. На команду всегда ДОЛЖЕН быть послан
   единственный ответ RE_LISTGROUPS, поле данных которого представляет
   собой массив NodeID всех групп (максимальное количество возможных
   групп, таким образом, ограничивается размером фрейма). Перечисляются
   все группы, в том числе приватные, соответственно, узлу СЛЕДУЕТ
   не указывать в списке групп в интерфейсе пользователя те группы,
   информацию по которым он не может получить.

4.3.7. CM_JOIN и CM_LEAVE

   Команды CM_JOIN и CM_LEAVE имеют формат поля данных, показанный на
   диаграмме:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |                            NodeID                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |                          GroupNodeID                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8

   Здесь NodeID - идентификатор узла, а GroupNodeID - идентификатор
   группы, с которой проводится операция. Команда CM_JOIN означает
   присоединение нового узла к группе, а с помощью CM_LEAVE узел
   может покинуть группу. Ответ на команды запрещен. В случае успешного
   выполнения сервер рассылает фрейм с командой всем членам группы,
   в том числе самому узлу, с которым производится операция (для него
   это служит подтверждением успешного выполнения). Все узлы по
   получении команды ДОЛЖНЫ обновить значения атрибута AT_NODELIST
   в структурах NodeInfo группы и затрагиваемого узла (это делается
   с целью уменьшения трафика для исключения перезапросов полных
   структур NodeInfo), с выставлением в них соответственно поля
   LastUpdTime.

   Если выполнение команды было неуспешным, узлу посылается команда
   CM_ERROR, идентифицирующая причину неудачи - это может происходить,
   например, в результате переполнения группы или превышения
   максимального числа групп в сети, или запрещения покидания серверной
   группы, или действия ограничений в структуре PrivInfo, и т.д.

   Группы (обычно это относится к клиентским группам, поскольку состав
   серверных более-менее фиксирован) автоматически создаются при
   присоединении к ним первого узла (сервер заполняет структуру
   NodeInfo полями по умолчанию в соответствии со своими настройками,
   поэтому клиенту следует запросить структуру NodeInfo и модифицировать
   её нужным образом) и уничтожаются, когда их покидает последний узел
   (по модели IRC). Если узел попытался покинуть группу, в которой
   он не состоял, это не считается ошибкой, и узлу просто возвращается
   его же "подтверждающий" фрейм CM_LEAVE (то же происходит при попытке
   присоединения к группе, в которой узел уже состоит).

4.3.8. CM_KICK

   Команда CM_KICK предназначена для принудительного прекращения
   членства узла в группе. Формат её данных:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |                            NodeID                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |                          GroupNodeID                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8
   |                        OperatorNodeID                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 12

   Поле OperatorNodeID указывает оператора группы, который произвел
   это действие. Реализация команды CM_KICK полностью аналогична
   командам CM_JOIN и CM_LEAVE, за исключением дополнительных проверок
   на операторство в группе. Кроме того, узлу запрещено прекращать
   членство в группе самого себя этой команду (т.е. NodeID не должно
   равняться OperatorNodeID).

4.4. Сообщения.

4.4.1. CM_LISTMSGS

   Команда CM_LISTMSGS предназначена для получения списка сообщений,
   адресованных определенному NodeID, который записывается в поле
   данных команды (допустим только один NodeID). Она используется для
   получения списка сообщений, которые могут быть запрошены в
   дальнейшем с удаленной стороны командой CM_GETMSG. С каждым узлом
   или группой может быть связан "почтовый ящик" (INSTANT INBOX в
   терминах [RFC 2778]), в который помещаются все предназначенные ему
   сообщения. Этот "ящик" может в принципе существовать на любом
   узле - если узел A посылал узлу B сообщения X и Y, он мог сохранить
   их в некоем кэше сообщений, и если, скажем, узел B потерял эти
   сообщения, он может дать узлу A команду CM_LISTMSGS со своим NodeID
   и получить список сообщений, адресованных себе, которые он всё еще
   может запросить. Аналогичным образом сервера хранят сообщения,
   адресованные группам, так что любой член группы может запросить
   групповые сообщения, посланные группе, скажем, в то время, когда
   он был выключен.

   В ответ на команду CM_LISTMSGS может быть выдан один из общих
   статусных кодов в случае ошибки, либо код RE_LISTMSGS в случае
   успешного выполнения команды. Поле данных кода RE_LISTMSGS
   содержит массив MsgID всех сообщений, адресованных запрошенному
   NodeID. Порядок MsgID ДОЛЖЕН соответствовать порядку, в котором
   сообщения поступали в "ящик" (максимально возможное количество
   сообщений в нем составляет 8191, исходя из размера фрейма).
   Поле данных ответа может быть пустым, если в "ящике" не содержится
   сообщений.

4.4.2. CM_GETMSG

   Для запроса сообщения с удаленной стороны применяется команда
   CM_GETMSG. Её поле данных содержит единственный MsgID сообщения,
   которое желает получить локальная сторона (этот MsgID может быть
   получен, к примеру, с помощью команды CM_LISTMSGS). В случае ошибки
   возвращается один из общих статусных кодов, в случае успеха же - код
   RE_MESSAGE, поле данных которого содержит запрошенное сообщение.

4.4.3. CM_SENDMSG

   Команда CM_SENDMSG может исходить только от сервера, в поле данных
   она содержит ровно одно сообщение. Ответ на команду запрещен,
   поскольку она применяется главным образом с целью ускорения
   обработки рассылки групповых сообщений (снижения нагрузки на сервер).

4.4.4. CM_POSTMSG

   Команда CM_POSTMSG применяется для обычной отправки сообщения. Её
   поле данных содержит сообщение, которое требуется отправить, в
   ответ, после всех проверок, удаленная сторона возвращает либо
   код RE_OK, либо один из общих статусных кодов ошибок. В случае
   отправки клиентом группового сообщения оно не отсылается сервером
   обратно клиенту, и тот сразу по получении RE_OK может отображать
   в пользователю новое групповое сообщение.

4.5. Прочие команды.

4.5.1. CM_DATAGRAM

   Команда передаёт дейтаграмму удаленной стороне. Ответ на команду
   запрещен (ошибки передаются специальными дейтаграммами, как описано
   в разделе 3.5). Поле данных содержит ровно одну дейтаграмму, таким
   образом, поле длины фрейма всегда равняется полю длины дейтаграммы
   (за исключением специальных дейтаграмм, с длиной 12).

4.5.2. CM_TIME

   Команда CM_TIME запрашивает время удаленной стороны. Данных в
   запросе нет, единственный код ответа RE_TIME имеет 4 байта данных,
   время удаленной стороны (см. раздел 3.1). Запрос времени имеет
   целью главным образом сокращение трафика на передачу структур
   NodeInfo, используя её поле LastUpdTime и запрос CM_GETNINFO_IMS.

4.5.3. CM_REGISTER

   Команда предназначена для регистрации нового NodeID на сервере
   (в сети), либо смены пароля. Формат данных команды:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |                           NewNodeID                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |                                                               |
   /                                                               /
   \                ClearTextPassword (variable length)            \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   В поле NewNodeID содержится NodeID узла, который должен быть
   зарегистрирован. В случае, если он свободен и никакие
   административные политики не препятствуют регистрации, сервер ДОЛЖЕН
   зарегистрировать именно этот NodeID.

   В поле ClearTextPassword содержится пароль в открытом виде (поскольку
   его должны знать и клиент, и сервер для успешного выполнения команды
   CM_AUTH в дальнейшем). РЕКОМЕНДУЕТСЯ использовать пароли длиной не
   менее 8 символов. Кодировка и прочие параметры пароля никак не
   исползуется, он ДОЛЖЕН рассмотриваться как просто поток байт.
   Следует отметить, что протокол в большинстве своих операций никак не
   использует шифрование и другие методы обеспечения конфиденциальности,
   поскольку предполагается, что в случае потребности в таковых мерах
   будет использован подходящий протокол безопасности транспортного
   уровня. Если нет возможности обеспечить такую безопасность для
   повседневных операций, возможно использовать регистрацию новых
   NodeID внешними по отношению к описанному здесь протоколу методами.

   В случае успешной регистрации сервер создает для клиента структуру
   NodeInfo и заполняет её значениями по умолчаниями, исходя из
   настроек сервера - например, клиент может быть сразу же включен в
   одну или несколько групп, основываясь на его IP-адресе и знании
   сервером структуры корпоративной сети (следует не забыть при этом
   посылку соответствующих CM_JOIN и т.п.). Если эти операции были
   успешны, сервер возвращает ответ RE_OK. После этого клиенту СЛЕДУЕТ
   запросить с сервера свою структуру NodeInfo, и при необходимости
   модифицировать её. Дальнейшая работа клиента и сервера ничем не
   отличается от обычного соединения зарегистрированного клиента сразу
   после стадии CM_AUTH.

   В случае неуспешной регистрации клиенту должен быть возвращен один
   из стандартных кодов ошибки либо код RE_REGFAILED. Формат его данных:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |                       RecommendedNodeID                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4
   |                                                               |
   /                                                               /
   \                 FailureReason (variable length)               \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Поле RecommendedNodeID, если имеет ненулевое значение, обозначает,
   что запрошенный клиентом NodeID не был свободен, и сервер
   рекомендует использовать указанное значение при повторной попытке
   регистрации. Если же это был NodeID, равный 0000-0000, то причина
   неудачной регистрации кроется в чем-то другом, и описывается полем
   FailureReason. Оно представляет собой текстовое сообщение, которое
   необходимо вывести пользователю (во избежание пробем с кодировками
   разрешено использовать только символы ASCII с кодами 32-126).

   У команды CM_REGISTER есть еще одно применение - узел, уже
   зарегистрированный ранее в сети, может послать её с новым паролем
   для смены его на сервере. Сервер ДОЛЖЕН принимать такие команды
   только после успешной аутентификации (поскольку локальные
   административные политики могут предусматривать повседневное
   обслуживание некоторого подмножетсва узлов без аутентификации).
   В случае успешной смены пароля возвращается RE_OK, в случае
   неуспешной - такой же RE_REGFAILED, как и при обычной регистрации
   (за исключением того, что ненулевой NodeID указывает просто на
   отсутствие текста причины и всегда игнорируется).


5. ССЫЛКИ.

   [FLOWED]    Gellens, R., "The Text/Plain Format Parameter", RFC 2646
               August 1999, and "The Text/Plain Format and DelSp
               Parameters", RFC 3676, February 2004.
   [MIME]      Freed, M., Borenstein, N., "Multipurpose Internet Mail
               Extensions (MIME)", RFC 2045-2049, November 1996.
   [RFC 793]   Postel, J., "Transmission Control Protocol", RFC 793,
               September 1981.
   [RFC 959]   Postel, J., Reynolds, J., "File Transfer Protocol",
               RFC 959, October 1985.
   [RFC 977]   Kantor. B., Lapsley, P., "Network News Transfer
               Protocol", RFC 977, February 1986.
   [RFC 1305]  Mills, D., "Network Time Protocol (Version 3)
               Specification, Implementation and Analysis", RFC 1305,
               March 1992.
   [RFC 1324]  Reed, D., "A Discussion on Computer Network
               Conferencing", RFC 1324, May 1992.
   [RFC 1510]  Kohl, J., Neuman, C., "The Kerberos Network
               Authentication Service (V5)", RFC 1510, September 1993.
   [RFC 1700]  Reynolds, J., Postel, J., "Assigned Numbers", RFC 1700,
               October 1994.
   [RFC 1896]  Resnick, P., Walker, A., "The text/enriched MIME
               Content-type", RFC 1896, February 1996.
   [RFC 1994]  Simpson, W., "PPP Challenge Handshake Authentication
               Protocol (CHAP)", RFC 1994, August 1996.
   [RFC 2104]  Krawczyk, H., Bellare, M., Canetti, R., "HMAC:
               Keyed-Hashing for Message Authentication", RFC 2104,
               February 1997.
   [RFC 2119]  Bradner, S., "Key words for use in RFCs to Indicate
               Requirement Levels", BCP 14, RFC 2119, March 1997.
   [RFC 2202]  Cheng, P., Glenn, R., "Test Cases for HMAC-MD5 and
               HMAC-SHA-1", RFC 2202, September 1997.
   [RFC 2778]  Day, M., Rosenberg, J., Sugano, H., "A Model for Presence
               and Instant Messaging", RFC 2778, February 2000.
   [RFC 2779]  Day, M., Aggarwal, S., Mohr, G., "Instant Messaging /
               Presence Protocol Requirements", RFC 2779, February 2000.
   [RFC 3208]  Speakman, T., et. al., "PGM Reliable Transport Protocol
               Specification", RFC 3208, December 2001.
   [RFC 3629]  Yergeau, F., "UTF-8, a transformation format of
               ISO 10646", RFC 3629, November 2003.
   [RFC 4231]  Nystrom, M., "Identifiers and Test Vectors for
               HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384, and
               HMAC-SHA-512", RFC 4231, December 2005.
   [RTF]       Microsoft Developers Network Library, "Rich Text Format
               (RTF) Specification, version 1.6", May 1999, <http://
               msdn.microsoft.com/library/en-us/dnrtfspec/html/
               rtfspec.asp>
   [XMPP]      Saint-Andre, P., Editor, "Extensible Messaging and
               Presence Protocol (XMPP)", RFC 3920 and RFC 3921,
               October 2004.


ПРИЛОЖЕНИЕ A. ФОРМАТИРОВАНИЕ ТЕКСТА.

   В этом Приложении рассматриваются вопросы разметки (форматирования)
   текста. В сообщениях (также возможно использование в других
   структурах протокола, например, расширениях) может возникнуть
   потребность передать, помимо самого текста, такие его характеристики,
   как размер, шрифт, начертание, цвет и т.п., а может быть, и некоторую
   встроенную нетекстовую информацию небольшого размера - пиктограммы,
   формулы и т.п. Для этого должна быть возможность однозначного
   интерпретирования разметки переданного текста. Этой цели служит
   поле Format, указывающее номер используемого формата текста. В
   настоящий момент определены следующие номера форматов:

   0 - plain text, отсутствие форматирования
   1 - mIRC control codes
   2 - text/enriched 
   3 - Rich Text Format (RTF), версия 1.6
   4 - HTML

   Формат 0 (отсутствие форматирования) ДОЛЖНА поддерживать любая
   реализация TheSender (своего рода "наименьший общий знаменатель").
   Формат 0 определяется в соответствии с [MIME], тип "text/plain".
   Учитывая природу обмена мгновенными групповыми сообщениями TheSender,
   реализации МОГУТ использовать цитирование текста сообщения, на
   которое производится ответ. В случае использования цитирования,
   реализациям СЛЕДУЕТ применять стандартный символ цитирования ">"
   и другие положения, описанные во [FLOWED].

   Формат 1 (mIRC color codes) подробно рассмотрен в следующем разделе.

   Формат 2, соответствующий MIME-типу "text/enriched", описан в
   [RFC 1896]. В протоколе TheSender используется одно расширение
   сверх описанного - тег <strike>, обозначающий перечеркнутый текст.
   РЕКОМЕНДУЕТСЯ поддержка формата 2 всеми реализациями TheSender:
   даже если реализация не в состоянии отобразить форматирование,
   из формата 2 легко может быть получен простой неформатированный
   текст формата 0 (фрагмент кода на языке Си, реализующий
   такое преобразование, приведен в [RFC 1896]), а индикация приема
   формата 2 в атрибуте AT_CAPFMT резрешит другим узлам отправлять свои
   сообщения в этом формате, позволяя поддерживающим узлам принять
   полноценный форматированный текст.

   Формат 3 представляет собой Rich Text Format (RTF) версии 1.6,
   описанный в [RTF].

   Формат 4 представляет собой одну из разновидностей HTML. Конкретная
   версия (и адрес спецификации) может быть определена из стандартного
   тега DOCTYPE в начале текста. Реализациям СЛЕДУЕТ, однако,
   использовать версию не менее 4.0.

A.1. Формат mIRC control codes.

   Формат 1 определяет простой метод передачи некоторых свойств
   форматирования символов без форматирования абзацев. Он применим
   главным образом в расширении чата (см. Приложение B), но может
   использоваться и для сообщений, поскольку подходит для терминалов
   с небольшим количеством возможностей. Формат является незначительной
   вариацией контрольных кодов, используемых IRC-клиентом mIRC.

   Форматирование задаётся кодами из множества управляющих символов
   ASCII (номера менее 32). Появление кода включает задаваемый им
   эффект для всех последующих символов текста, вплоть до появления
   такого же кода (таким образом, появление кода действует на поток
   текста как переключатель эффекта) или кода отмены любого
   форматирования. Конец строки также отменяет любое форматирование.
   В остальном, кроме нижеописанного, формат совпадает с форматом 0.

   Используемые коды эффектов:

   0x02 - жирный
   0x03 - цветной текст
   0x0f - сброс любого форматирования
   0x16 - инверсный текст (меняются местами цвета текста и фона)
   0x1f - подчеркивание

   Отдельно необходимо отметить код 0x03, задающий цвет текста, и,
   возможно, фона текста. Этот код использует несколько последующих
   символов текста (которые, таким образом, не принадлежат тексту)
   как аргумент, указывающий цвет. Это всегда ДОЛЖНЫ быть две
   десятичные цифры, указывающие цвет текста. В случае указания фона
   текста за этими двумя цифрами следует запятая с двумя другими
   цифрами, указывающими цвет фона. Цвет фона не может указываться один,
   он всегда ДОЛЖЕН быть указан вместе с цветом текста. Реализаторам
   следует обратить внимание на проблему отличения номера цвета от
   последующего текста (поскольку они ничем не разделена), например,
   в случае задания цвета текста перед встречающейсяв тексте запятой
   или выделения цветом посреди строки цифр. Использование правил
   заданий всегда двух цифр позволяет избежать неоднозначности (хотя
   некоторые реализации МОГУТ также в целях совместимости поддерживать
   приём кодов без лидирующих нулей).
   
   Допустимые номера цветов:

   0  - белый (white)
   1  - черный (black)
   2  - темно-синий (blue / navy)
   3  - зеленый (green)
   4  - красный (red)
   5  - коричневый (brown / maroon)
   6  - фиолетовый (purple)
   7  - оранжевый (orange / olive)
   8  - желтый (yellow)
   9  - светло-зеленый (lightgreen / lime)
   10 - бирюзовый/циан (teal / a kinda green/blue cyan)
   11 - светло-бирюзовый/голубой (lightcyan / aqua)
   12 - ярко-синий (lightblue / royal)
   13 - розовый/светлофиолетовый/лиловый (pink / light purple / fuchsia)
   14 - темно-серый (grey)
   15 - светло-серый (lightgrey/silver)

   Пример текста "это коричневый на светло-зеленом фоне" в формате 1:

     это ^C05,09коричневый на светло-зеленом^O фоне

   Здесь слова "коричневый на светло-зеленом" будут выделены указанным
   цветом (в примере ^C означало символ 0x03, а ^O - 0x0f).


ПРИЛОЖЕНИЕ B. ЧАТ И ПЕРЕДАЧА ФАЙЛОВ.

   Данное Приложение стандартизирует расширения протокола, которые
   должна поддерживать каждая реализация TheSender - прямой диалог в
   реальном времени (чат) между двумя пользователями и отправку файлов
   одним пользователем другому.

   Эти возможности строятся на системе дейтаграмм - чат использует
   точку доступа 1/dg, передача файлов же 2/dg. Далее следует описание
   этих "субпротоколов".

B.1. Чат.

   Система TheSender в обычном режиме предназначена для обмена
   сообщениями, написание и получение которых неинтерактивны, поскольку
   не требуют от пользователя немедленной реакции в реальном времени.
   Это нормально, так как пользователь сам планирует свое время, и
   другие пользователи не смогут его отвлекать, если он того пожелает.
   Иногда, однако, на сравнительно короткое время требуется
   интерактивный диалог между двумя пользователями.

   Чат в системе TheSender построен на модели, концептуально аналогичной
   телефонному звонку. Пусть есть два пользователя, Вызывающий (В) и
   Отвечающий (О). Оба занимаются своими делами, но вот В срочно
   потребовалось переговорить с О. Он делает ему "звонок" - вызывает его
   на чат. О же, в свою очередь, может принять решение ответить на
   "звонок", и тогда между В и О устанавливается чат, "не брать трубку"
   (его может и не быть рядом с компьютером в этот момент) или даже
   отказаться от предлагаемого чата. Чтобы довершить аналогию с
   мобильной связью, программное обеспечение О может предоставлять и
   другие функции, например, записать дату и время "звонка", на который
   не было ответа, предоставив удобные средства быстрого ответа.

   После установления чат ведется в обычном понимании этого слова, являя
   простой обмен текстовыми строками, продолжающийся до тех пор, пока
   один из участников не прервет "разговор", "положив трубку".

   Технически вызов на чат представляет собой обмен дейтаграммами между
   В (с эфемерной точки) и О (на точку 1/dg).

B.1.1. Формат данных.

   Дейтаграммы в целом имеют формат, приведенный ниже:

      1 байт                  от 0 до 511 байт
     ___/^\___   ______________________/^\________________________
    /         \ /                                                 \
   +-----------+----------------.........................----------+
   |   OpCode  |                      Data                         |
   +-----------+----------------.........................----------+

   Здесь OpCode означает код операции, а интерпретация поля данных
   зависит от значения OpCode, которое может принимать следующие
   значения:

      0 - запрос на чат (единственный запрос, все остальные - ответы)
      1 - ошибка: неподдерживаемый формат или кодовая страница
      2 - пользователь О принял чат
      3 - пользователь О отклонил запрос на чат
      4 - дейтаграмма данных с сообщением чата
      5 - ошибка в данных или команде (сброс диалога)
      6 - один из пользователей завершил диалог

   Все остальные значения зарезервированы и не должны использоваться.

   Дейтаграммы с кодами 1, 3, 5, 6 состоят только из поля OpCode (имеют
   размер 1 байт). Дейтаграмма с кодом 4 может иметь произвольный
   размер поля данных, 1 байт OpCode и от 0 до 511 байт данных
   сообщения пользователя. Дейтаграммы с кодами 0 и 2 предназначены для
   согласования параметров и всегда имеют размер 4 октета, их формат
   показан на диаграмме:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |     OpCode    |R|L|  Format   |          CodePage             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4

   Значения полей:

   Format

      Предлагаемый формат текста чата, который будет использоваться
      стороной, пославшей эту дейтаграмму. Является значением того же
      типа, что и формат текста обычного сообщения, и рассматривается
      соответственно в Приложении A "Форматирование текста".

   CodePage

      Поля имеют такое же самое значение, что и соответствующие поля в
      заголовке обычного сообщения, и означают кодировку (язык),
      которую собирается использовать сторона, пославшая эту
      дейтаграмму. Подробно расссматривается в Приложении C "Языки и
      кодовые страницы".

   L

      Флаг поддержки "живого" (live) чата (подробнее ниже).

   R 

      Бит зарезервирован для будущего использования.

B.1.2. Порядок операций.

   В начале В и О неопределенно долгое время находятся в исходном
   состоянии - чат между ними не идет, соответствующие части
   программного обеспечения бездействуют, несущее соединение может
   (и обычно это так и есть) вообще отсутствовать. Используемый
   далее по тексту интервал, называемый "максимальный период ожидания",
   составляет 15 минут.

   Вызов на чат начинается с того, что В отправляет дейтаграмму с
   эфемерной точки на 1/dg (ответ, как и положено дейтаграммам, приходит
   с 1/dg О на эту эфемерную точку В), код операции которой равен нулю,
   что означает запрос на чат. Значения полей формата и языка - те,
   которые В будет использовать в своих строках (как в чате, так и в
   тексте причины, если таковая будет указываться).

   О, в течение максимального периода ожидания, должен прислать ответную
   дейтаграмму (если таковой не было, пользователю В сообщается о
   неудаче вызова). Ответная дейтаграмма может иметь код 2, означающий
   прием вызова на чат, а может и код 3, означающий, что пользователь
   отказался от чата. В случае отказа программное обеспечение В извещает
   об этом своего пользоватля, и программное обеспечение узлов (часть,
   отвечающая за чат) возвращается в исходное состояние (сброс чата).
   Следует отметить, что в ответ на запрос от О может не придти
   вообще ничего, если, например, пользователя О нет у компьютера, и
   он так и не дал ни положительного, ни отрицательного ответа. В этом
   случае по истечении максимального периода ожидания происходит сброс
   чата.

   В случае, если требуемая последовательность обмена дейтаграммами
   нарушается (например, пришла дейтаграмма данных вместо кода приема
   или отказа, или О получил дейтаграмм данных без предварительного
   согласования, и т.д.), чат сбрасывается в исходное состояние
   посылкой кода 5. То же происходит и в случае, если В не дождался
   ответа О и решил прекратить "дозвон" до истечения максимального
   периода ожидания.

   Вместо обычной дейтаграммы с кодом операции В может получить
   служебную дейтаграмму, извещающую о том, что точка доступа не
   используется приложением. Это происходит, например, в том случае,
   если пользователь узла О отключил чат (например, при уходе в режим
   Away) - программное обеспечение узла МОЖЕТ предоставлять
   пользователю такую возможность. В этом случае чат также
   сбрасывается.

   Прием В дейтаграммы с кодом 2 означает, что параметры языка и
   формата В были приняты стороной О, и значение этих полей в ответной
   дейтаграмме есть то значение, которое будет использовать сторона О.
   Сторону О, однако, могут не устроить язык и/или формат, которые
   намеревается использовать В (они могут просто не поддерживаться
   программным обеспечением узла О), в каковом случае О вместо кода 2
   выдает дейтаграмму с кодом 1 (рекомендуется делать это сразу, не
   выводя пользователю диалог запроса на прием "звонка"), после чего
   чат сбрасывается. Узел В МОЖЕТ предпринять еще одну попытку с другими
   значениями полей, прозрачную для пользователя В, но с точки зрения
   протокола это будут две разные попытки вызова на чат.

   Разумеется, может случится ситуация, когда О примет параметры В и
   ответит кодом 2, но В не примет ответные параметры О. В этом
   случае В тоже отвечает кодом 1. Чат при этом сбрасывается, но
   реализации МОГУТ не показывать этого пользователю, поскольку
   согласование в этом случае всегда может быть закончено успешно,
   ввиду того, что О может использовать те же значение, что и исходно
   В, так как О их поддерживает, раз уже принял.

   Если согласование прошло успешно, то чат переходит в установленную
   фазу. Идет обмен дейтаграммами с кодом 4 до тех пор, пока одна из
   сторон не решит прекратить чат посылкой дейтаграммы с кодом 6.
   Поскольку чат интерактивен и обмен сообщениями происходит в обоих
   направлениях, передача данных другой стороной теряет смысл, и 
   чат считается полностью прекращенным (сброшенным), а стороны В и О
   возвращаются в исходное состояние.
   
B.1.3. Установленная фаза чата.

   Традиционная и повсеместно распространенная концептуальная модель
   чата заключается в наличии у каждого пользователя окна, в котором
   отображены все введенные ранее фразы (с указанием автора), и поля
   для редактирования, в котором пользовтаель вводит и правит очередную
   строку, но после отправки ее в сеть (и добавления ее в окно) уже не
   может отредактировать свой текст. Данная модель - практически
   единственная возможная при участии в чате более двух пользователей.

   Существует (и иногда встречается), однако, и другая модель чата двух
   пользователей. Каждый имеет два окна - свое и собеседника. Каждый
   вводит и редактирует текст в своем окне, и весь процесс отображается
   в соответствующем окне собеседника. Таким образом, видно появление и
   стирание символов (это практически отображение нажатия клавиш), что в
   некоторой степени делает общение более живым, поэтому такой режим
   чата назван здесь "живым", live-чатом.

   Рассматриваемый в этом Приложении чат двух пользователей TheSender
   позволяет реализовать обе модели. При согласовании параметров
   сторона, желающая установить live-чат, устанавливает флаг L. Если
   флаг L был установлен обеими сторонами, устанаваливается режим
   live-чата, в противном случае реализуется обычный чат. В обычном
   режиме каждая дейтаграмма данных представляет собой передачу строки
   текста (явные разделители строк CR LF не требуются), в live-режиме
   каждая дейтаграмма передаёт одну или несколько набранных букв, а при
   необходимости перевода строки посылаются символы CR LF.

   Формат передаваемых строк в основном определяется соответствующим
   полем в дейтаграммах при установке чата, хотя есть свои особенности.
   Двоичные нули (байты 0x00) недопустимы (что не относится к UCS-2).
   Два символа, ASCII 0x07 и 0x08, имеют специальное значение. Байт со
   значением 0x07 (BELL в ASCII) не должен показываться (вырезается из
   потока) - при его получении программное обеспечение узла должно
   привлечь внимание пользователя подачей звукового сигнала (и/или
   какими-либо визуальными средствами, в зависимости от возможностей
   аппаратного и программного обеспечения узла). Байт со значением 0x08
   (BackSpace) предназначен для реализации live-чата и
   выполняет действие одноименной клавиши - стирает (и соответствующим
   образом переводит курсор или выполняет аналогичное действие, в
   зависимости от архитектуры узла) последний выведенный символ.
   Повторение - предпоследний символ, и так далее, аналогично работе
   с клавиатуры. Реализации обычной модели должны игнорировать символ
   0x08 (и live-модели), но здесь уже все оставляется на усмотрение
   реализатора, исходя из рекомендаций по самим форматам.

   В случае live-чата другая сторона видит набираемый текст сразу же
   по мере набора, в обычном режиме же задержки на редактирование
   строки могут быть достаточно долгими, что вызывает необходимость
   введения уведомления другой стороны о том, что локальный польователь
   сейчас набирает текст (typing notifications). Это достигается
   путем введения для каждой из двух сторон флага в памяти, набирает
   ли она текст сейчас. В начале флаг сброшен для обеих сторон. Посылка
   "пустой" дейтаграммы с кодом 4 (0 байт данных) инвертирует этот
   флаг для стороны отправителя, кроме того, этот флаг всегда
   сбрасывается по приходу "нормальной" дейтаграммы с данными. Таким
   образом, например, если узел В засекает, что его пользователь
   редактирует текст, он отправляет уведомление, и сторона О, к
   примеру, показывает своему пользователю, что другая сторона набирает
   текст. Через некоторый таймаут В обнаруживает, что пользователь
   не нажимает на клавиши, и снова отправлет такую же дейтаграмму-
   уведомление, как в первый раз, и О перестает показывать своему
   пользователю уведомление. Так может повторяться несколько раз, до
   тех пор, пока, при установленном флаге, В не отправит сообщение,
   и оно не сбросит своим приходом флаг уведомления о наборе у О (хотя
   оно могло и не показываться, а В просто отправил сообщение, уже
   не редактируя его непосредственно перед набором). 

B.2. Передача файлов.

   Одним из достаточно востребованных сервисов у программ общения в
   наше время является передача файлов от одного пользователя к другому.
   В системе TheSender существует возможность передачи небольшого
   файла (до 64 Кбайт) вместе с сообщением. Однако, как показывает
   практика, имеется потребность в передаче файлов гораздо большего
   размера (иногда до нескольких гигабайт). Для этого предусмотрено
   стандартное расширение протокола, использующее точку доступа 2.

   Концептуально передача файлов достаточно проста: пользователь A
   желает отправить пользователю B один файл, для чего дает команду
   программному обеспечению своего узла на передачу выбранного файла
   на узел B. Пользователь B получает запрос на прием файла, и, если
   он дает разрешение, узлы производят передачу файла между собой.

   Реализация этой схемы, однако, более сложна, поскольку должны быть
   предусмотрены как средства для быстрой и надежной передачи файла,
   так и возможность для дальнейшего расширения (например,
   автоматической передачи группы файлов). Технически это выглядит
   как передача дейтаграмм на точку доступа 2 узла B. Кроме дейтаграмм,
   для скоростной передачи делается попытка установить специальное
   TCP-соединение для передачи файлов, аналогично соединению данных
   протокола FTP [RFC 959]. Если это удается, весь трафик соединения
   состоит только из данных файла (в обратную сторону не передается
   ничего). В случае неудачи (файрволы, NAT, и т.д.), делается попытка
   установить соединение в другом направлении. В случае повторной
   неудачи, узлы переходят к передаче данных файла дейтаграммами
   через сервер. Необходимо отметить, что этот режим является
   вынужденным, существует лишь для обеспечения возможности передачи
   файлов в любых условиях, и является низкоскоростным, так как сервер
   не обязан тратить большое количество ресурсов на обслуживание
   этих двух клиентов сравнительно с остальными (РЕКОМЕНДУЕТСЯ, однако,
   обеспечивать скорость через сервер хотя бы 1 Кбайт в секунду).

B.2.1. Формат дейтаграмм.

   Дейтаграммы в целом имеют формат, приведенный ниже:

      4 байта                 от 0 до 65519 байт
     ___/^\___   ______________________/^\________________________
    /         \ /                                                 \
   +-----------+----------------.........................----------+
   |   Header  |                      Data                         |
   +-----------+----------------.........................----------+

   Заголовок имеет постоянный формат, приведенный ниже, для дейтаграмм
   всех типов операций:

    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0
   |    OpCode     |   RESERVED    |         TransactionID         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4

   Здесь OpCode - код операции этой дейтаграммы, а TransactionID являет
   собой некий уникальный для узла-получателя файла идентификатор
   передачи. Он должен быть одинаков для всех дейтаграмм передачи одного
   и того же файла. Назначение этого поля - использование сервиса
   передачи файлов другими приложениями (в терминах раздела 3.5.1).
   Например, два приложения могут согласовать номера транзакций,
   сообщить их сервисам передачи файлов своих узлов, и дальнейшая
   передача файлов будет осуществлена автоматически без участия
   пользователя. Поэтому узел, принимающий файл, ДОЛЖЕН принять файл
   без отображения запроса пользователю, если номер транзакции ему
   известен; в противном случае МОЖЕТ быть выведен запрос (в зависимости
   от настроек узла). Номер транзакции 0 считается зарезервированным,
   и приложения, использующие сервис передачи файлов, НЕ ДОЛЖНЫ его
   использовать. Это сделано с целью устранения возможного совпадения
   номеров с какой-либо другой передачей на узле-получателе при большой
   нагрузке, поскольку вероятность этого ненулевая. Узлы-отправители
   файлов МОГУТ использовать номер транзакции 0 для передачи файлов,
   инициированных непосредственно пользователем, вместо генерации
   случайного значения.

   Определены следующие коды операций:

   Константа           Значение  Краткое описание

   FT_REQUEST          0         Запрос на передачу файла
   FT_ACK              1         Положительный ответ на запрос
   FT_NAK              2         Отказ от приема файла
   FT_RESET            3         Сброс передачи
   FT_CONNECTED        4         Удачное соединение
   FT_CONNFAIL         5         Неудача соединения
   FT_DATA             6         Дейтаграмма с данными файла
   FT_ACCEPTOK         7         Файл успешно принят получателем





   |                                                               |
   /                                                               /
   \                               (variable length)               \
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+



ПРИЛОЖЕНИЕ C. ЯЗЫКИ И КОДОВЫЕ СТРАНИЦЫ.

C.1. Общая информация.

   Высока вероятность применения пакета программ TheSender в
   гетерогенных средах, с необходимостью использования национальных
   алфавитов. Поэтому в протокол вводится поддержка различных наборов
   символов (charset), которыми может представляться текстовая
   информация различных языков и того же языка на различных платформах.
   Каждый такой набор именуется кодовой страницей (code page) с
   присвоенным ему номером. В ряде структур протокола, в которых
   возникает необходимость передачи текста, введено поле CodePage,
   содержащее номер кодовой страницы, согласно которой следует
   интерпретировать текст. Кодировка и декодировка текста производится
   только оконечным программным обеспечением, поэтому все промежуточные
   уровни протокола ДОЛЖНЫ интерпретировать текст как
   неструктурированный ("сырой") поток байт, в котором могут встречаться
   любые значения, в том числе ASCII 0 (таким образом, нельзя полагаться
   на использование какого-либо символа признаком конца текста, а вместо
   этого следует использовать явно указанную в заголовках длину).

   Два номера кодовых страниц - специальные, они означают не кодовую
   страницу, а варианты передачи кодирования стандарта Unicode:

   65001 - UTF-8
   65534 - UCS-2 
   
   В UCS-2 каждый символ кодируется двуя байтами, причем могут
   встречаться нулевые байты. Для передачи UCS-2 используется сетевой
   порядок байт.

   Возможно также нулевое значение поля CodePage - оно означает, что
   кодовая страница неизвестна (скорее всего, не поддерживается узлом
   отправителя, то есть, возможно это просто ASCII-символы).

C.2. Перечень номеров кодовых страниц.

   Ниже перечислены определенные в настоящий момент номера кодовых
   страниц (кроме указанных выше). Они в основном совпадают с номерами
   кодовых страниц Microsoft/IBM. Все остальные номера, не указанные
   в этом Приложении, зарезервированы.

   Номер   Название

   037     IBM EBCDIC - U.S./Canada 
   437     OEM - United States 
   500     IBM EBCDIC - International  
   708     Arabic - ASMO 708 
   709     Arabic - ASMO 449+, BCON V4 
   710     Arabic - Transparent Arabic 
   720     Arabic - Transparent ASMO 
   737     OEM - Greek (formerly 437G) 
   775     OEM - Baltic 
   850     OEM - Multilingual Latin I 
   852     OEM - Latin II 
   855     OEM - Cyrillic (primarily Russian) 
   857     OEM - Turkish 
   858     OEM - Multlingual Latin I + Euro symbol 
   860     OEM - Portuguese 
   861     OEM - Icelandic 
   862     OEM - Hebrew 
   863     OEM - Canadian-French 
   864     OEM - Arabic 
   865     OEM - Nordic 
   866     OEM - Russian 
   869     OEM - Modern Greek 
   870     IBM EBCDIC - Multilingual/ROECE (Latin-2) 
   874     ANSI/OEM - Thai (same as 28605, ISO 8859-15) 
   875     IBM EBCDIC - Modern Greek 
   932     ANSI/OEM - Japanese, Shift-JIS 
   936     ANSI/OEM - Simplified Chinese (PRC, Singapore) 
   949     ANSI/OEM - Korean (Unified Hangeul Code) 
   950     ANSI/OEM - Traditional Chinese (Taiwan; Hong Kong SAR, PRC)  
   1026    IBM EBCDIC - Turkish (Latin-5) 
   1047    IBM EBCDIC - Latin 1/Open System 
   1140    IBM EBCDIC - U.S./Canada (037 + Euro symbol) 
   1141    IBM EBCDIC - Germany (20273 + Euro symbol) 
   1142    IBM EBCDIC - Denmark/Norway (20277 + Euro symbol) 
   1143    IBM EBCDIC - Finland/Sweden (20278 + Euro symbol) 
   1144    IBM EBCDIC - Italy (20280 + Euro symbol) 
   1145    IBM EBCDIC - Latin America/Spain (20284 + Euro symbol) 
   1146    IBM EBCDIC - United Kingdom (20285 + Euro symbol) 
   1147    IBM EBCDIC - France (20297 + Euro symbol) 
   1148    IBM EBCDIC - International (500 + Euro symbol) 
   1149    IBM EBCDIC - Icelandic (20871 + Euro symbol) 
   1250    ANSI - Central European  
   1251    ANSI - Cyrillic 
   1252    ANSI - Latin I  
   1253    ANSI - Greek 
   1254    ANSI - Turkish 
   1255    ANSI - Hebrew 
   1256    ANSI - Arabic 
   1257    ANSI - Baltic 
   1258    ANSI/OEM - Vietnamese 
   1361    Korean (Johab) 
   10000   MAC - Roman 
   10001   MAC - Japanese 
   10002   MAC - Traditional Chinese (Big5) 
   10003   MAC - Korean 
   10004   MAC - Arabic 
   10005   MAC - Hebrew 
   10006   MAC - Greek I 
   10007   MAC - Cyrillic 
   10008   MAC - Simplified Chinese (GB 2312) 
   10010   MAC - Romania 
   10017   MAC - Ukraine 
   10021   MAC - Thai 
   10029   MAC - Latin II 
   10079   MAC - Icelandic 
   10081   MAC - Turkish 
   10082   MAC - Croatia 
   20000   CNS - Taiwan  
   20001   TCA - Taiwan  
   20002   Eten - Taiwan  
   20003   IBM5550 - Taiwan  
   20004   TeleText - Taiwan  
   20005   Wang - Taiwan  
   20105   IA5 IRV International Alphabet No. 5 (7-bit) 
   20106   IA5 German (7-bit) 
   20107   IA5 Swedish (7-bit) 
   20108   IA5 Norwegian (7-bit) 
   20127   US-ASCII (7-bit) 
   20261   T.61 
   20269   ISO 6937 Non-Spacing Accent 
   20273   IBM EBCDIC - Germany 
   20277   IBM EBCDIC - Denmark/Norway 
   20278   IBM EBCDIC - Finland/Sweden 
   20280   IBM EBCDIC - Italy 
   20284   IBM EBCDIC - Latin America/Spain 
   20285   IBM EBCDIC - United Kingdom 
   20290   IBM EBCDIC - Japanese Katakana Extended 
   20297   IBM EBCDIC - France 
   20420   IBM EBCDIC - Arabic 
   20423   IBM EBCDIC - Greek 
   20424   IBM EBCDIC - Hebrew 
   20833   IBM EBCDIC - Korean Extended 
   20838   IBM EBCDIC - Thai 
   20866   Russian - KOI8-R 
   20871   IBM EBCDIC - Icelandic 
   20880   IBM EBCDIC - Cyrillic (Russian) 
   20905   IBM EBCDIC - Turkish 
   20924   IBM EBCDIC - Latin-1/Open System (1047 + Euro symbol) 
   20932   JIS X 0208-1990 & 0121-1990 
   20936   Simplified Chinese (GB2312) 
   21025   IBM EBCDIC - Cyrillic (Serbian, Bulgarian) 
   21027   Extended Alpha Lowercase 
   21866   Ukrainian (KOI8-U) 
   28591   ISO 8859-1 Latin I 
   28592   ISO 8859-2 Central Europe 
   28593   ISO 8859-3 Latin 3  
   28594   ISO 8859-4 Baltic 
   28595   ISO 8859-5 Cyrillic 
   28596   ISO 8859-6 Arabic 
   28597   ISO 8859-7 Greek 
   28598   ISO 8859-8 Hebrew 
   28599   ISO 8859-9 Latin 5 
   28605   ISO 8859-15 Latin 9 
   29001   Europa 3 
   38598   ISO 8859-8 Hebrew 
   50220   ISO 2022 Japanese with no halfwidth Katakana 
   50221   ISO 2022 Japanese with halfwidth Katakana 
   50222   ISO 2022 Japanese JIS X 0201-1989 
   50225   ISO 2022 Korean  
   50227   ISO 2022 Simplified Chinese 
   50229   ISO 2022 Traditional Chinese 
   50930   Japanese (Katakana) Extended 
   50931   US/Canada and Japanese 
   50933   Korean Extended and Korean 
   50935   Simplified Chinese Extended and Simplified Chinese 
   50936   Simplified Chinese 
   50937   US/Canada and Traditional Chinese 
   50939   Japanese (Latin) Extended and Japanese 
   51932   EUC - Japanese 
   51936   EUC - Simplified Chinese 
   51949   EUC - Korean 
   51950   EUC - Traditional Chinese 
   52936   HZ-GB2312 Simplified Chinese  
   57002   ISCII Devanagari 
   57003   ISCII Bengali 
   57004   ISCII Tamil 
   57005   ISCII Telugu 
   57006   ISCII Assamese 
   57007   ISCII Oriya 
   57008   ISCII Kannada 
   57009   ISCII Malayalam 
   57010   ISCII Gujarati 
   57011   ISCII Punjabi 

